{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"isomorphic-unfetch\");\n\nvar QueryString = require(\"query-string\");\n\nvar types_1 = require(\"./types\");\n\nvar utils_1 = require(\"./utils\");\n\nexports.ORDERBOOK_VERSION = 1;\nexports.API_VERSION = 1;\nexports.API_BASE_MAINNET = 'https://api.opensea.io';\nexports.API_BASE_RINKEBY = 'https://rinkeby-api.opensea.io';\nexports.SITE_HOST_MAINNET = 'https://opensea.io';\nexports.SITE_HOST_RINKEBY = 'https://rinkeby.opensea.io';\nvar ORDERBOOK_PATH = \"/wyvern/v\" + exports.ORDERBOOK_VERSION;\nvar API_PATH = \"/api/v\" + exports.ORDERBOOK_VERSION;\n\nvar OpenSeaAPI = function () {\n  /**\n   * Create an instance of the OpenSea API\n   * @param config OpenSeaAPIConfig for setting up the API, including an optional API key, network name, and base URL\n   * @param logger Optional function for logging debug strings before and after requests are made\n   */\n  function OpenSeaAPI(config, logger) {\n    /**\n     * Page size to use for fetching orders\n     */\n    this.pageSize = 20;\n    this.apiKey = config.apiKey;\n\n    switch (config.networkName) {\n      case types_1.Network.Rinkeby:\n        this.apiBaseUrl = config.apiBaseUrl || exports.API_BASE_RINKEBY;\n        this.hostUrl = exports.SITE_HOST_RINKEBY;\n        break;\n\n      case types_1.Network.Main:\n      default:\n        this.apiBaseUrl = config.apiBaseUrl || exports.API_BASE_MAINNET;\n        this.hostUrl = exports.SITE_HOST_MAINNET;\n        break;\n    } // Debugging: default to nothing\n\n\n    this.logger = logger || function (arg) {\n      return arg;\n    };\n  }\n  /**\n   * Send an order to the orderbook.\n   * Throws when the order is invalid.\n   * IN NEXT VERSION: change order input to Order type\n   * @param order Order JSON to post to the orderbook\n   * @param retries Number of times to retry if the service is unavailable for any reason\n   */\n\n\n  OpenSeaAPI.prototype.postOrder = function (order, retries) {\n    if (retries === void 0) {\n      retries = 2;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var response, error_1, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 4]);\n\n            return [4\n            /*yield*/\n            , this.post(ORDERBOOK_PATH + \"/orders/post\", order)];\n\n          case 1:\n            response = _a.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            error_1 = _a.sent();\n\n            _throwOrContinue(error_1, retries);\n\n            return [4\n            /*yield*/\n            , utils_1.delay(3000)];\n\n          case 3:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , this.postOrder(order, retries - 1)];\n\n          case 4:\n            return [4\n            /*yield*/\n            , response.json()];\n\n          case 5:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , utils_1.orderFromJSON(json)];\n        }\n      });\n    });\n  };\n  /**\n   * Create a whitelist entry for an asset to prevent others from buying.\n   * Buyers will have to have verified at least one of the emails\n   * on an asset in order to buy.\n   * This will throw a 403 if the given API key isn't allowed to create whitelist entries for this contract or asset.\n   * @param tokenAddress Address of the asset's contract\n   * @param tokenId The asset's token ID\n   * @param email The email allowed to buy.\n   */\n\n\n  OpenSeaAPI.prototype.postAssetWhitelist = function (tokenAddress, tokenId, email) {\n    return __awaiter(this, void 0, void 0, function () {\n      var response, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.post(API_PATH + \"/asset/\" + tokenAddress + \"/\" + tokenId + \"/whitelist/\", {\n              email: email\n            })];\n\n          case 1:\n            response = _a.sent();\n            return [4\n            /*yield*/\n            , response.json()];\n\n          case 2:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , !!json.success];\n        }\n      });\n    });\n  };\n  /**\n   * Get an order from the orderbook, throwing if none is found.\n   * @param query Query to use for getting orders. A subset of parameters\n   *  on the `OrderJSON` type is supported\n   */\n\n\n  OpenSeaAPI.prototype.getOrder = function (query) {\n    return __awaiter(this, void 0, void 0, function () {\n      var response, orderJSON, json, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.get(ORDERBOOK_PATH + \"/orders\", __assign({\n              limit: 1\n            }, query))];\n\n          case 1:\n            response = _a.sent();\n            if (!(exports.ORDERBOOK_VERSION == 0)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , response.json()];\n\n          case 2:\n            json = _a.sent();\n            orderJSON = json[0];\n            return [3\n            /*break*/\n            , 5];\n\n          case 3:\n            return [4\n            /*yield*/\n            , response.json()];\n\n          case 4:\n            json = _a.sent();\n            orderJSON = json.orders[0];\n            _a.label = 5;\n\n          case 5:\n            if (!orderJSON) {\n              throw new Error(\"Not found: no matching order found\");\n            }\n\n            return [2\n            /*return*/\n            , utils_1.orderFromJSON(orderJSON)];\n        }\n      });\n    });\n  };\n  /**\n   * Get a list of orders from the orderbook, returning the page of orders\n   *  and the count of total orders found.\n   * @param query Query to use for getting orders. A subset of parameters\n   *  on the `OrderJSON` type is supported\n   * @param page Page number, defaults to 1. Can be overridden by\n   * `limit` and `offset` attributes from OrderQuery\n   */\n\n\n  OpenSeaAPI.prototype.getOrders = function (query, page) {\n    if (query === void 0) {\n      query = {};\n    }\n\n    if (page === void 0) {\n      page = 1;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var response, json, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.get(ORDERBOOK_PATH + \"/orders\", __assign({\n              limit: this.pageSize,\n              offset: (page - 1) * this.pageSize\n            }, query))];\n\n          case 1:\n            response = _a.sent();\n            if (!(exports.ORDERBOOK_VERSION == 0)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , response.json()];\n\n          case 2:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , {\n              orders: json.map(function (j) {\n                return utils_1.orderFromJSON(j);\n              }),\n              count: json.length\n            }];\n\n          case 3:\n            return [4\n            /*yield*/\n            , response.json()];\n\n          case 4:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , {\n              orders: json.orders.map(function (j) {\n                return utils_1.orderFromJSON(j);\n              }),\n              count: json.count\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch an asset from the API, throwing if none is found\n   * @param tokenAddress Address of the asset's contract\n   * @param tokenId The asset's token ID, or null if ERC-20\n   * @param retries Number of times to retry if the service is unavailable for any reason\n   */\n\n\n  OpenSeaAPI.prototype.getAsset = function (tokenAddress, tokenId, retries) {\n    if (retries === void 0) {\n      retries = 1;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var response, error_2, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 4]);\n\n            return [4\n            /*yield*/\n            , this.get(API_PATH + \"/asset/\" + tokenAddress + \"/\" + (tokenId || 0))];\n\n          case 1:\n            response = _a.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            error_2 = _a.sent();\n\n            _throwOrContinue(error_2, retries);\n\n            return [4\n            /*yield*/\n            , utils_1.delay(1000)];\n\n          case 3:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , this.getAsset(tokenAddress, tokenId, retries - 1)];\n\n          case 4:\n            return [4\n            /*yield*/\n            , response.json()];\n\n          case 5:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , utils_1.assetFromJSON(json)];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch list of assets from the API, returning the page of assets and the count of total assets\n   * @param query Query to use for getting orders. A subset of parameters on the `OpenSeaAssetJSON` type is supported\n   * @param page Page number, defaults to 1. Can be overridden by\n   * `limit` and `offset` attributes from OpenSeaAssetQuery\n   */\n\n\n  OpenSeaAPI.prototype.getAssets = function (query, page) {\n    if (query === void 0) {\n      query = {};\n    }\n\n    if (page === void 0) {\n      page = 1;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var response, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.get(API_PATH + \"/assets/\", __assign({\n              limit: this.pageSize,\n              offset: (page - 1) * this.pageSize\n            }, query))];\n\n          case 1:\n            response = _a.sent();\n            return [4\n            /*yield*/\n            , response.json()];\n\n          case 2:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , {\n              assets: json.assets.map(function (j) {\n                return utils_1.assetFromJSON(j);\n              }),\n              estimatedCount: json.estimated_count\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch list of fungible tokens from the API matching paramters\n   * @param query Query to use for getting orders. A subset of parameters on the `OpenSeaAssetJSON` type is supported\n   * @param page Page number, defaults to 1. Can be overridden by\n   * `limit` and `offset` attributes from OpenSeaFungibleTokenQuery\n   * @param retries Number of times to retry if the service is unavailable for any reason\n   */\n\n\n  OpenSeaAPI.prototype.getPaymentTokens = function (query, page, retries) {\n    if (query === void 0) {\n      query = {};\n    }\n\n    if (page === void 0) {\n      page = 1;\n    }\n\n    if (retries === void 0) {\n      retries = 1;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var response, error_3, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 4]);\n\n            return [4\n            /*yield*/\n            , this.get(API_PATH + \"/tokens/\", __assign({}, query, {\n              limit: this.pageSize,\n              offset: (page - 1) * this.pageSize\n            }))];\n\n          case 1:\n            response = _a.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            error_3 = _a.sent();\n\n            _throwOrContinue(error_3, retries);\n\n            return [4\n            /*yield*/\n            , utils_1.delay(1000)];\n\n          case 3:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , this.getPaymentTokens(query, page, retries - 1)];\n\n          case 4:\n            return [4\n            /*yield*/\n            , response.json()];\n\n          case 5:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , {\n              tokens: json.map(function (t) {\n                return utils_1.tokenFromJSON(t);\n              })\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch an bundle from the API, return null if it isn't found\n   * @param tokenAddress Address of the bundle's contract\n   * @param tokenId The bundle's token ID\n   */\n\n\n  OpenSeaAPI.prototype.getBundle = function (slug) {\n    return __awaiter(this, void 0, void 0, function () {\n      var response, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.get(API_PATH + \"/bundle/\" + slug + \"/\")];\n\n          case 1:\n            response = _a.sent();\n            return [4\n            /*yield*/\n            , response.json()];\n\n          case 2:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , json ? utils_1.assetBundleFromJSON(json) : null];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch list of bundles from the API, returning the page of bundles and the count of total bundles\n   * @param query Query to use for getting orders. A subset of parameters on the `OpenSeaAssetBundleJSON` type is supported\n   * @param page Page number, defaults to 1. Can be overridden by\n   * `limit` and `offset` attributes from OpenSeaAssetBundleQuery\n   */\n\n\n  OpenSeaAPI.prototype.getBundles = function (query, page) {\n    if (query === void 0) {\n      query = {};\n    }\n\n    if (page === void 0) {\n      page = 1;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var response, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.get(API_PATH + \"/bundles/\", __assign({}, query, {\n              limit: this.pageSize,\n              offset: (page - 1) * this.pageSize\n            }))];\n\n          case 1:\n            response = _a.sent();\n            return [4\n            /*yield*/\n            , response.json()];\n\n          case 2:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , {\n              bundles: json.bundles.map(function (j) {\n                return utils_1.assetBundleFromJSON(j);\n              }),\n              estimatedCount: json.estimated_count\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Get JSON data from API, sending auth token in headers\n   * @param apiPath Path to URL endpoint under API\n   * @param query Data to send. Will be stringified using QueryString\n   */\n\n\n  OpenSeaAPI.prototype.get = function (apiPath, query) {\n    if (query === void 0) {\n      query = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var qs, url;\n      return __generator(this, function (_a) {\n        qs = QueryString.stringify(query);\n        url = apiPath + \"?\" + qs;\n        return [2\n        /*return*/\n        , this._fetch(url)];\n      });\n    });\n  };\n  /**\n   * POST JSON data to API, sending auth token in headers\n   * @param apiPath Path to URL endpoint under API\n   * @param body Data to send. Will be JSON.stringified\n   * @param opts RequestInit opts, similar to Fetch API. If it contains\n   *  a body, it won't be stringified.\n   */\n\n\n  OpenSeaAPI.prototype.post = function (apiPath, body, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var fetchOpts;\n      return __generator(this, function (_a) {\n        fetchOpts = __assign({\n          method: 'POST',\n          body: body ? JSON.stringify(body) : undefined,\n          headers: {\n            Accept: 'application/json',\n            'Content-Type': 'application/json'\n          }\n        }, opts);\n        return [2\n        /*return*/\n        , this._fetch(apiPath, fetchOpts)];\n      });\n    });\n  };\n  /**\n   * PUT JSON data to API, sending auth token in headers\n   * @param apiPath Path to URL endpoint under API\n   * @param body Data to send\n   * @param opts RequestInit opts, similar to Fetch API. If it contains\n   *  a body, it won't be stringified.\n   */\n\n\n  OpenSeaAPI.prototype.put = function (apiPath, body, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.post(apiPath, body, __assign({\n          method: 'PUT'\n        }, opts))];\n      });\n    });\n  };\n  /**\n   * Get from an API Endpoint, sending auth token in headers\n   * @param apiPath Path to URL endpoint under API\n   * @param opts RequestInit opts, similar to Fetch API\n   */\n\n\n  OpenSeaAPI.prototype._fetch = function (apiPath, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var apiBase, apiKey, finalUrl, finalOpts;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        apiBase = this.apiBaseUrl;\n        apiKey = this.apiKey;\n        finalUrl = apiBase + apiPath;\n        finalOpts = __assign({}, opts, {\n          headers: __assign({}, apiKey ? {\n            'X-API-KEY': apiKey\n          } : {}, opts.headers || {})\n        });\n        this.logger(\"Sending request: \" + finalUrl + \" \" + JSON.stringify(finalOpts).substr(0, 100) + \"...\");\n        return [2\n        /*return*/\n        , fetch(finalUrl, finalOpts).then(function (res) {\n          return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n              return [2\n              /*return*/\n              , this._handleApiResponse(res)];\n            });\n          });\n        })];\n      });\n    });\n  };\n\n  OpenSeaAPI.prototype._handleApiResponse = function (response) {\n    return __awaiter(this, void 0, void 0, function () {\n      var result, errorMessage, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (response.ok) {\n              this.logger(\"Got success: \" + response.status);\n              return [2\n              /*return*/\n              , response];\n            }\n\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , response.text()];\n\n          case 2:\n            result = _b.sent();\n            result = JSON.parse(result);\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            _a = _b.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            this.logger(\"Got error \" + response.status + \": \" + JSON.stringify(result));\n\n            switch (response.status) {\n              case 400:\n                errorMessage = result && result.errors ? result.errors.join(', ') : \"Invalid request: \" + JSON.stringify(result);\n                break;\n\n              case 401:\n              case 403:\n                errorMessage = \"Unauthorized. Full message was '\" + JSON.stringify(result) + \"'\";\n                break;\n\n              case 404:\n                errorMessage = \"Not found. Full message was '\" + JSON.stringify(result) + \"'\";\n                break;\n\n              case 500:\n                errorMessage = \"Internal server error. OpenSea has been alerted, but if the problem persists please contact us via Discord: https://discord.gg/ga8EJbv - full message was \" + JSON.stringify(result);\n                break;\n\n              case 503:\n                errorMessage = \"Service unavailable. Please try again in a few minutes. If the problem persists please contact us via Discord: https://discord.gg/ga8EJbv - full message was \" + JSON.stringify(result);\n                break;\n\n              default:\n                errorMessage = \"Message: \" + JSON.stringify(result);\n                break;\n            }\n\n            throw new Error(\"API Error \" + response.status + \": \" + errorMessage);\n        }\n      });\n    });\n  };\n\n  return OpenSeaAPI;\n}();\n\nexports.OpenSeaAPI = OpenSeaAPI;\n\nfunction _throwOrContinue(error, retries) {\n  var isUnavailable = !!error.message && (error.message.includes('503') || error.message.includes('429'));\n\n  if (retries <= 0 || !isUnavailable) {\n    throw error;\n  }\n}","map":{"version":3,"sources":["../src/api.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"isomorphic-unfetch\");\nvar QueryString = require(\"query-string\");\nvar types_1 = require(\"./types\");\nvar utils_1 = require(\"./utils\");\nexports.ORDERBOOK_VERSION = 1;\nexports.API_VERSION = 1;\nexports.API_BASE_MAINNET = 'https://api.opensea.io';\nexports.API_BASE_RINKEBY = 'https://rinkeby-api.opensea.io';\nexports.SITE_HOST_MAINNET = 'https://opensea.io';\nexports.SITE_HOST_RINKEBY = 'https://rinkeby.opensea.io';\nvar ORDERBOOK_PATH = \"/wyvern/v\" + exports.ORDERBOOK_VERSION;\nvar API_PATH = \"/api/v\" + exports.ORDERBOOK_VERSION;\nvar OpenSeaAPI = /** @class */ (function () {\n    /**\n     * Create an instance of the OpenSea API\n     * @param config OpenSeaAPIConfig for setting up the API, including an optional API key, network name, and base URL\n     * @param logger Optional function for logging debug strings before and after requests are made\n     */\n    function OpenSeaAPI(config, logger) {\n        /**\n         * Page size to use for fetching orders\n         */\n        this.pageSize = 20;\n        this.apiKey = config.apiKey;\n        switch (config.networkName) {\n            case types_1.Network.Rinkeby:\n                this.apiBaseUrl = config.apiBaseUrl || exports.API_BASE_RINKEBY;\n                this.hostUrl = exports.SITE_HOST_RINKEBY;\n                break;\n            case types_1.Network.Main:\n            default:\n                this.apiBaseUrl = config.apiBaseUrl || exports.API_BASE_MAINNET;\n                this.hostUrl = exports.SITE_HOST_MAINNET;\n                break;\n        }\n        // Debugging: default to nothing\n        this.logger = logger || (function (arg) { return arg; });\n    }\n    /**\n     * Send an order to the orderbook.\n     * Throws when the order is invalid.\n     * IN NEXT VERSION: change order input to Order type\n     * @param order Order JSON to post to the orderbook\n     * @param retries Number of times to retry if the service is unavailable for any reason\n     */\n    OpenSeaAPI.prototype.postOrder = function (order, retries) {\n        if (retries === void 0) { retries = 2; }\n        return __awaiter(this, void 0, void 0, function () {\n            var response, error_1, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 4]);\n                        return [4 /*yield*/, this.post(ORDERBOOK_PATH + \"/orders/post\", order)];\n                    case 1:\n                        response = _a.sent();\n                        return [3 /*break*/, 4];\n                    case 2:\n                        error_1 = _a.sent();\n                        _throwOrContinue(error_1, retries);\n                        return [4 /*yield*/, utils_1.delay(3000)];\n                    case 3:\n                        _a.sent();\n                        return [2 /*return*/, this.postOrder(order, retries - 1)];\n                    case 4: return [4 /*yield*/, response.json()];\n                    case 5:\n                        json = _a.sent();\n                        return [2 /*return*/, utils_1.orderFromJSON(json)];\n                }\n            });\n        });\n    };\n    /**\n     * Create a whitelist entry for an asset to prevent others from buying.\n     * Buyers will have to have verified at least one of the emails\n     * on an asset in order to buy.\n     * This will throw a 403 if the given API key isn't allowed to create whitelist entries for this contract or asset.\n     * @param tokenAddress Address of the asset's contract\n     * @param tokenId The asset's token ID\n     * @param email The email allowed to buy.\n     */\n    OpenSeaAPI.prototype.postAssetWhitelist = function (tokenAddress, tokenId, email) {\n        return __awaiter(this, void 0, void 0, function () {\n            var response, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.post(API_PATH + \"/asset/\" + tokenAddress + \"/\" + tokenId + \"/whitelist/\", {\n                            email: email\n                        })];\n                    case 1:\n                        response = _a.sent();\n                        return [4 /*yield*/, response.json()];\n                    case 2:\n                        json = _a.sent();\n                        return [2 /*return*/, !!json.success];\n                }\n            });\n        });\n    };\n    /**\n     * Get an order from the orderbook, throwing if none is found.\n     * @param query Query to use for getting orders. A subset of parameters\n     *  on the `OrderJSON` type is supported\n     */\n    OpenSeaAPI.prototype.getOrder = function (query) {\n        return __awaiter(this, void 0, void 0, function () {\n            var response, orderJSON, json, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.get(ORDERBOOK_PATH + \"/orders\", __assign({ limit: 1 }, query))];\n                    case 1:\n                        response = _a.sent();\n                        if (!(exports.ORDERBOOK_VERSION == 0)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, response.json()];\n                    case 2:\n                        json = _a.sent();\n                        orderJSON = json[0];\n                        return [3 /*break*/, 5];\n                    case 3: return [4 /*yield*/, response.json()];\n                    case 4:\n                        json = _a.sent();\n                        orderJSON = json.orders[0];\n                        _a.label = 5;\n                    case 5:\n                        if (!orderJSON) {\n                            throw new Error(\"Not found: no matching order found\");\n                        }\n                        return [2 /*return*/, utils_1.orderFromJSON(orderJSON)];\n                }\n            });\n        });\n    };\n    /**\n     * Get a list of orders from the orderbook, returning the page of orders\n     *  and the count of total orders found.\n     * @param query Query to use for getting orders. A subset of parameters\n     *  on the `OrderJSON` type is supported\n     * @param page Page number, defaults to 1. Can be overridden by\n     * `limit` and `offset` attributes from OrderQuery\n     */\n    OpenSeaAPI.prototype.getOrders = function (query, page) {\n        if (query === void 0) { query = {}; }\n        if (page === void 0) { page = 1; }\n        return __awaiter(this, void 0, void 0, function () {\n            var response, json, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.get(ORDERBOOK_PATH + \"/orders\", __assign({ limit: this.pageSize, offset: (page - 1) * this.pageSize }, query))];\n                    case 1:\n                        response = _a.sent();\n                        if (!(exports.ORDERBOOK_VERSION == 0)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, response.json()];\n                    case 2:\n                        json = _a.sent();\n                        return [2 /*return*/, {\n                                orders: json.map(function (j) { return utils_1.orderFromJSON(j); }),\n                                count: json.length\n                            }];\n                    case 3: return [4 /*yield*/, response.json()];\n                    case 4:\n                        json = _a.sent();\n                        return [2 /*return*/, {\n                                orders: json.orders.map(function (j) { return utils_1.orderFromJSON(j); }),\n                                count: json.count\n                            }];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch an asset from the API, throwing if none is found\n     * @param tokenAddress Address of the asset's contract\n     * @param tokenId The asset's token ID, or null if ERC-20\n     * @param retries Number of times to retry if the service is unavailable for any reason\n     */\n    OpenSeaAPI.prototype.getAsset = function (tokenAddress, tokenId, retries) {\n        if (retries === void 0) { retries = 1; }\n        return __awaiter(this, void 0, void 0, function () {\n            var response, error_2, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 4]);\n                        return [4 /*yield*/, this.get(API_PATH + \"/asset/\" + tokenAddress + \"/\" + (tokenId || 0))];\n                    case 1:\n                        response = _a.sent();\n                        return [3 /*break*/, 4];\n                    case 2:\n                        error_2 = _a.sent();\n                        _throwOrContinue(error_2, retries);\n                        return [4 /*yield*/, utils_1.delay(1000)];\n                    case 3:\n                        _a.sent();\n                        return [2 /*return*/, this.getAsset(tokenAddress, tokenId, retries - 1)];\n                    case 4: return [4 /*yield*/, response.json()];\n                    case 5:\n                        json = _a.sent();\n                        return [2 /*return*/, utils_1.assetFromJSON(json)];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch list of assets from the API, returning the page of assets and the count of total assets\n     * @param query Query to use for getting orders. A subset of parameters on the `OpenSeaAssetJSON` type is supported\n     * @param page Page number, defaults to 1. Can be overridden by\n     * `limit` and `offset` attributes from OpenSeaAssetQuery\n     */\n    OpenSeaAPI.prototype.getAssets = function (query, page) {\n        if (query === void 0) { query = {}; }\n        if (page === void 0) { page = 1; }\n        return __awaiter(this, void 0, void 0, function () {\n            var response, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.get(API_PATH + \"/assets/\", __assign({ limit: this.pageSize, offset: (page - 1) * this.pageSize }, query))];\n                    case 1:\n                        response = _a.sent();\n                        return [4 /*yield*/, response.json()];\n                    case 2:\n                        json = _a.sent();\n                        return [2 /*return*/, {\n                                assets: json.assets.map(function (j) { return utils_1.assetFromJSON(j); }),\n                                estimatedCount: json.estimated_count\n                            }];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch list of fungible tokens from the API matching paramters\n     * @param query Query to use for getting orders. A subset of parameters on the `OpenSeaAssetJSON` type is supported\n     * @param page Page number, defaults to 1. Can be overridden by\n     * `limit` and `offset` attributes from OpenSeaFungibleTokenQuery\n     * @param retries Number of times to retry if the service is unavailable for any reason\n     */\n    OpenSeaAPI.prototype.getPaymentTokens = function (query, page, retries) {\n        if (query === void 0) { query = {}; }\n        if (page === void 0) { page = 1; }\n        if (retries === void 0) { retries = 1; }\n        return __awaiter(this, void 0, void 0, function () {\n            var response, error_3, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 4]);\n                        return [4 /*yield*/, this.get(API_PATH + \"/tokens/\", __assign({}, query, { limit: this.pageSize, offset: (page - 1) * this.pageSize }))];\n                    case 1:\n                        response = _a.sent();\n                        return [3 /*break*/, 4];\n                    case 2:\n                        error_3 = _a.sent();\n                        _throwOrContinue(error_3, retries);\n                        return [4 /*yield*/, utils_1.delay(1000)];\n                    case 3:\n                        _a.sent();\n                        return [2 /*return*/, this.getPaymentTokens(query, page, retries - 1)];\n                    case 4: return [4 /*yield*/, response.json()];\n                    case 5:\n                        json = _a.sent();\n                        return [2 /*return*/, {\n                                tokens: json.map(function (t) { return utils_1.tokenFromJSON(t); })\n                            }];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch an bundle from the API, return null if it isn't found\n     * @param tokenAddress Address of the bundle's contract\n     * @param tokenId The bundle's token ID\n     */\n    OpenSeaAPI.prototype.getBundle = function (slug) {\n        return __awaiter(this, void 0, void 0, function () {\n            var response, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.get(API_PATH + \"/bundle/\" + slug + \"/\")];\n                    case 1:\n                        response = _a.sent();\n                        return [4 /*yield*/, response.json()];\n                    case 2:\n                        json = _a.sent();\n                        return [2 /*return*/, json ? utils_1.assetBundleFromJSON(json) : null];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch list of bundles from the API, returning the page of bundles and the count of total bundles\n     * @param query Query to use for getting orders. A subset of parameters on the `OpenSeaAssetBundleJSON` type is supported\n     * @param page Page number, defaults to 1. Can be overridden by\n     * `limit` and `offset` attributes from OpenSeaAssetBundleQuery\n     */\n    OpenSeaAPI.prototype.getBundles = function (query, page) {\n        if (query === void 0) { query = {}; }\n        if (page === void 0) { page = 1; }\n        return __awaiter(this, void 0, void 0, function () {\n            var response, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.get(API_PATH + \"/bundles/\", __assign({}, query, { limit: this.pageSize, offset: (page - 1) * this.pageSize }))];\n                    case 1:\n                        response = _a.sent();\n                        return [4 /*yield*/, response.json()];\n                    case 2:\n                        json = _a.sent();\n                        return [2 /*return*/, {\n                                bundles: json.bundles.map(function (j) { return utils_1.assetBundleFromJSON(j); }),\n                                estimatedCount: json.estimated_count\n                            }];\n                }\n            });\n        });\n    };\n    /**\n     * Get JSON data from API, sending auth token in headers\n     * @param apiPath Path to URL endpoint under API\n     * @param query Data to send. Will be stringified using QueryString\n     */\n    OpenSeaAPI.prototype.get = function (apiPath, query) {\n        if (query === void 0) { query = {}; }\n        return __awaiter(this, void 0, void 0, function () {\n            var qs, url;\n            return __generator(this, function (_a) {\n                qs = QueryString.stringify(query);\n                url = apiPath + \"?\" + qs;\n                return [2 /*return*/, this._fetch(url)];\n            });\n        });\n    };\n    /**\n     * POST JSON data to API, sending auth token in headers\n     * @param apiPath Path to URL endpoint under API\n     * @param body Data to send. Will be JSON.stringified\n     * @param opts RequestInit opts, similar to Fetch API. If it contains\n     *  a body, it won't be stringified.\n     */\n    OpenSeaAPI.prototype.post = function (apiPath, body, opts) {\n        if (opts === void 0) { opts = {}; }\n        return __awaiter(this, void 0, void 0, function () {\n            var fetchOpts;\n            return __generator(this, function (_a) {\n                fetchOpts = __assign({ method: 'POST', body: body ? JSON.stringify(body) : undefined, headers: {\n                        Accept: 'application/json',\n                        'Content-Type': 'application/json',\n                    } }, opts);\n                return [2 /*return*/, this._fetch(apiPath, fetchOpts)];\n            });\n        });\n    };\n    /**\n     * PUT JSON data to API, sending auth token in headers\n     * @param apiPath Path to URL endpoint under API\n     * @param body Data to send\n     * @param opts RequestInit opts, similar to Fetch API. If it contains\n     *  a body, it won't be stringified.\n     */\n    OpenSeaAPI.prototype.put = function (apiPath, body, opts) {\n        if (opts === void 0) { opts = {}; }\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.post(apiPath, body, __assign({ method: 'PUT' }, opts))];\n            });\n        });\n    };\n    /**\n     * Get from an API Endpoint, sending auth token in headers\n     * @param apiPath Path to URL endpoint under API\n     * @param opts RequestInit opts, similar to Fetch API\n     */\n    OpenSeaAPI.prototype._fetch = function (apiPath, opts) {\n        if (opts === void 0) { opts = {}; }\n        return __awaiter(this, void 0, void 0, function () {\n            var apiBase, apiKey, finalUrl, finalOpts;\n            var _this = this;\n            return __generator(this, function (_a) {\n                apiBase = this.apiBaseUrl;\n                apiKey = this.apiKey;\n                finalUrl = apiBase + apiPath;\n                finalOpts = __assign({}, opts, { headers: __assign({}, (apiKey ? { 'X-API-KEY': apiKey } : {}), (opts.headers || {})) });\n                this.logger(\"Sending request: \" + finalUrl + \" \" + JSON.stringify(finalOpts).substr(0, 100) + \"...\");\n                return [2 /*return*/, fetch(finalUrl, finalOpts).then(function (res) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {\n                        return [2 /*return*/, this._handleApiResponse(res)];\n                    }); }); })];\n            });\n        });\n    };\n    OpenSeaAPI.prototype._handleApiResponse = function (response) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, errorMessage, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (response.ok) {\n                            this.logger(\"Got success: \" + response.status);\n                            return [2 /*return*/, response];\n                        }\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, response.text()];\n                    case 2:\n                        result = _b.sent();\n                        result = JSON.parse(result);\n                        return [3 /*break*/, 4];\n                    case 3:\n                        _a = _b.sent();\n                        return [3 /*break*/, 4];\n                    case 4:\n                        this.logger(\"Got error \" + response.status + \": \" + JSON.stringify(result));\n                        switch (response.status) {\n                            case 400:\n                                errorMessage = result && result.errors\n                                    ? result.errors.join(', ')\n                                    : \"Invalid request: \" + JSON.stringify(result);\n                                break;\n                            case 401:\n                            case 403:\n                                errorMessage = \"Unauthorized. Full message was '\" + JSON.stringify(result) + \"'\";\n                                break;\n                            case 404:\n                                errorMessage = \"Not found. Full message was '\" + JSON.stringify(result) + \"'\";\n                                break;\n                            case 500:\n                                errorMessage = \"Internal server error. OpenSea has been alerted, but if the problem persists please contact us via Discord: https://discord.gg/ga8EJbv - full message was \" + JSON.stringify(result);\n                                break;\n                            case 503:\n                                errorMessage = \"Service unavailable. Please try again in a few minutes. If the problem persists please contact us via Discord: https://discord.gg/ga8EJbv - full message was \" + JSON.stringify(result);\n                                break;\n                            default:\n                                errorMessage = \"Message: \" + JSON.stringify(result);\n                                break;\n                        }\n                        throw new Error(\"API Error \" + response.status + \": \" + errorMessage);\n                }\n            });\n        });\n    };\n    return OpenSeaAPI;\n}());\nexports.OpenSeaAPI = OpenSeaAPI;\nfunction _throwOrContinue(error, retries) {\n    var isUnavailable = !!error.message && (error.message.includes('503') ||\n        error.message.includes('429'));\n    if (retries <= 0 || !isUnavailable) {\n        throw error;\n    }\n}\n//# sourceMappingURL=api.js.map"]},"metadata":{},"sourceType":"script"}