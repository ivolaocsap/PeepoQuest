{"ast":null,"code":"import { Contract } from '@ethersproject/contracts';\nimport { defineReadOnly } from '@ethersproject/properties';\n\nfunction buildSafeCall(contract, signature, fragment) {\n  if (fragment.constant) {\n    // keep view function as is\n    return (...args) => contract[signature](...args);\n  }\n\n  return async (...args) => {\n    return contract.estimateGas[signature](...args).then(() => contract[signature](...args)).catch(estimateError => {\n      var _estimateError$data, _estimateError$data$m;\n\n      if ((estimateError === null || estimateError === void 0 ? void 0 : estimateError.code) === -32603 && (estimateError === null || estimateError === void 0 ? void 0 : (_estimateError$data = estimateError.data) === null || _estimateError$data === void 0 ? void 0 : (_estimateError$data$m = _estimateError$data.message) === null || _estimateError$data$m === void 0 ? void 0 : _estimateError$data$m.includes('always failing transaction'))) {\n        // extract real error code\n        return contract.callStatic[signature](...args).then(() => {\n          console.log('????');\n        }).catch(callError => {\n          throw callError;\n        });\n      }\n\n      throw estimateError;\n    });\n  };\n}\n\nexport class BinanceContract extends Contract {\n  constructor(addressOrName, contractInterface, signerOrProvider) {\n    super(addressOrName, contractInterface, signerOrProvider);\n    this.signerOrProvider = signerOrProvider;\n    this.safeCall = {};\n    Object.keys(this.interface.functions).forEach(signature => {\n      const fragment = this.interface.functions[signature];\n      defineReadOnly(this.safeCall, fragment.name, buildSafeCall(this, signature, fragment));\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/ivopascoal/Desktop/cuffies/src/diamondhand/BinanceContract.ts"],"names":["Contract","defineReadOnly","buildSafeCall","contract","signature","fragment","constant","args","estimateGas","then","catch","estimateError","code","data","message","includes","callStatic","console","log","callError","BinanceContract","constructor","addressOrName","contractInterface","signerOrProvider","safeCall","Object","keys","interface","functions","forEach","name"],"mappings":"AAAA,SAASA,QAAT,QAA8D,0BAA9D;AAGA,SAASC,cAAT,QAA+B,2BAA/B;;AAGA,SAASC,aAAT,CAAuBC,QAAvB,EAA2CC,SAA3C,EAA8DC,QAA9D,EAA0F;AACxF,MAAIA,QAAQ,CAACC,QAAb,EAAuB;AACrB;AACA,WAAO,CAAC,GAAGC,IAAJ,KAAkBJ,QAAQ,CAACC,SAAD,CAAR,CAAoB,GAAGG,IAAvB,CAAzB;AACD;;AACD,SAAO,OAAO,GAAGA,IAAV,KAA0B;AAC/B,WAAOJ,QAAQ,CAACK,WAAT,CAAqBJ,SAArB,EAAgC,GAAGG,IAAnC,EACJE,IADI,CACC,MAAMN,QAAQ,CAACC,SAAD,CAAR,CAAoB,GAAGG,IAAvB,CADP,EAEJG,KAFI,CAEGC,aAAD,IAAmB;AAAA;;AACxB,UACE,CAAAA,aAAa,SAAb,IAAAA,aAAa,WAAb,YAAAA,aAAa,CAAEC,IAAf,MAAwB,CAAC,KAAzB,KACAD,aADA,aACAA,aADA,8CACAA,aAAa,CAAEE,IADf,iFACA,oBAAqBC,OADrB,0DACA,sBAA8BC,QAA9B,CAAuC,4BAAvC,CADA,CADF,EAGE;AACA;AACA,eAAOZ,QAAQ,CAACa,UAAT,CAAoBZ,SAApB,EAA+B,GAAGG,IAAlC,EACJE,IADI,CACC,MAAM;AACVQ,UAAAA,OAAO,CAACC,GAAR,CAAY,MAAZ;AACD,SAHI,EAIJR,KAJI,CAIGS,SAAD,IAAe;AACpB,gBAAMA,SAAN;AACD,SANI,CAAP;AAOD;;AACD,YAAMR,aAAN;AACD,KAjBI,CAAP;AAkBD,GAnBD;AAoBD;;AAED,OAAO,MAAMS,eAAN,SAA8BpB,QAA9B,CAAuC;AAG5CqB,EAAAA,WAAW,CACTC,aADS,EAETC,iBAFS,EAGCC,gBAHD,EAIT;AACA,UAAMF,aAAN,EAAqBC,iBAArB,EAAwCC,gBAAxC;AADA,SADUA,gBACV,GADUA,gBACV;AAAA,SANFC,QAME,GAN2C,EAM3C;AAEAC,IAAAA,MAAM,CAACC,IAAP,CAAY,KAAKC,SAAL,CAAeC,SAA3B,EAAsCC,OAAtC,CAA+C1B,SAAD,IAAe;AAC3D,YAAMC,QAAQ,GAAG,KAAKuB,SAAL,CAAeC,SAAf,CAAyBzB,SAAzB,CAAjB;AACAH,MAAAA,cAAc,CAAC,KAAKwB,QAAN,EAAgBpB,QAAQ,CAAC0B,IAAzB,EAA+B7B,aAAa,CAAC,IAAD,EAAOE,SAAP,EAAkBC,QAAlB,CAA5C,CAAd;AACD,KAHD;AAID;;AAb2C","sourcesContent":["import { Contract, ContractFunction, ContractInterface } from '@ethersproject/contracts';\nimport { Signer } from '@ethersproject/abstract-signer';\nimport { Provider } from '@ethersproject/providers';\nimport { defineReadOnly } from '@ethersproject/properties';\nimport { FunctionFragment } from '@ethersproject/abi';\n\nfunction buildSafeCall(contract: Contract, signature: string, fragment: FunctionFragment) {\n  if (fragment.constant) {\n    // keep view function as is\n    return (...args: any) => contract[signature](...args);\n  }\n  return async (...args: any[]) => {\n    return contract.estimateGas[signature](...args)\n      .then(() => contract[signature](...args))\n      .catch((estimateError) => {\n        if (\n          estimateError?.code === -32603 &&\n          estimateError?.data?.message?.includes('always failing transaction')\n        ) {\n          // extract real error code\n          return contract.callStatic[signature](...args)\n            .then(() => {\n              console.log('????');\n            })\n            .catch((callError) => {\n              throw callError;\n            });\n        }\n        throw estimateError;\n      });\n  };\n}\n\nexport class BinanceContract extends Contract {\n  safeCall: Record<string, ContractFunction> = {};\n\n  constructor(\n    addressOrName: string,\n    contractInterface: ContractInterface,\n    protected signerOrProvider?: Signer | Provider,\n  ) {\n    super(addressOrName, contractInterface, signerOrProvider);\n    Object.keys(this.interface.functions).forEach((signature) => {\n      const fragment = this.interface.functions[signature];\n      defineReadOnly(this.safeCall, fragment.name, buildSafeCall(this, signature, fragment));\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}