{"ast":null,"code":"/*\nLicense gpl-3.0 http://www.gnu.org/licenses/gpl-3.0-standalone.html\n*/\n\n/*jslint\n    white: true,\n    vars: true,\n    node: true\n*/\nfunction ObjectMergeOptions(opts) {\n  'use strict';\n\n  opts = opts || {};\n  this.depth = opts.depth || false; // circular ref check is true unless explicitly set to false\n  // ignore the jslint warning here, it's pointless.\n\n  this.throwOnCircularRef = 'throwOnCircularRef' in opts && opts.throwOnCircularRef === false ? false : true;\n}\n/*jslint unparam:true*/\n\n/**\n * Creates a new options object suitable for use with objectMerge.\n * @memberOf objectMerge\n * @param {Object} [opts] An object specifying the options.\n * @param {Object} [opts.depth = false] Specifies the depth to traverse objects\n *  during merging. If this is set to false then there will be no depth limit.\n * @param {Object} [opts.throwOnCircularRef = true] Set to false to suppress\n *  errors on circular references.\n * @returns {ObjectMergeOptions} Returns an instance of ObjectMergeOptions\n *  to be used with objectMerge.\n * @example\n *  var opts = objectMerge.createOptions({\n *      depth : 2,\n *      throwOnCircularRef : false\n *  });\n *  var obj1 = {\n *      a1 : {\n *          a2 : {\n *              a3 : {}\n *          }\n *      }\n *  };\n *  var obj2 = {\n *      a1 : {\n *          a2 : {\n *              a3 : 'will not be in output'\n *          },\n *          a22 : {}\n *      }\n *  };\n *  objectMerge(opts, obj1, obj2);\n */\n\n\nfunction createOptions(opts) {\n  'use strict';\n\n  var argz = Array.prototype.slice.call(arguments, 0);\n  argz.unshift(null);\n  var F = ObjectMergeOptions.bind.apply(ObjectMergeOptions, argz);\n  return new F();\n}\n/*jslint unparam:false*/\n\n/**\n * Merges JavaScript objects recursively without altering the objects merged.\n * @namespace Merges JavaScript objects recursively without altering the objects merged.\n * @author <a href=\"mailto:matthewkastor@gmail.com\">Matthew Kastor</a>\n * @param {ObjectMergeOptions} [opts] An options object created by \n *  objectMerge.createOptions. Options must be specified as the first argument\n *  and must be an object created with createOptions or else the object will\n *  not be recognized as an options object and will be merged instead.\n * @param {Object} shadows [[shadows]...] One or more objects to merge. Each\n *  argument given will be treated as an object to merge. Each object\n *  overwrites the previous objects descendant properties if the property name\n *  matches. If objects properties are objects they will be merged recursively\n *  as well.\n * @returns {Object} Returns a single merged object composed from clones of the\n *  input objects.\n * @example\n *  var objectMerge = require('object-merge');\n *  var x = {\n *      a : 'a',\n *      b : 'b',\n *      c : {\n *          d : 'd',\n *          e : 'e',\n *          f : {\n *              g : 'g'\n *          }\n *      }\n *  };\n *  var y = {\n *      a : '`a',\n *      b : '`b',\n *      c : {\n *          d : '`d'\n *      }\n *  };\n *  var z = {\n *      a : {\n *          b : '``b'\n *      },\n *      fun : function foo () {\n *          return 'foo';\n *      },\n *      aps : Array.prototype.slice\n *  };\n *  var out = objectMerge(x, y, z);\n *  // out.a will be {\n *  //         b : '``b'\n *  //     }\n *  // out.b will be '`b'\n *  // out.c will be {\n *  //         d : '`d',\n *  //         e : 'e',\n *  //         f : {\n *  //             g : 'g'\n *  //         }\n *  //     }\n *  // out.fun will be a clone of z.fun\n *  // out.aps will be equal to z.aps\n */\n\n\nfunction objectMerge(shadows) {\n  'use strict';\n\n  var objectForeach = require('object-foreach');\n\n  var cloneFunction = require('clone-function'); // this is the queue of visited objects / properties.\n\n\n  var visited = []; // various merge options\n\n  var options = {}; // gets the sequential trailing objects from array.\n\n  function getShadowObjects(shadows) {\n    var out = shadows.reduce(function (collector, shadow) {\n      if (shadow instanceof Object) {\n        collector.push(shadow);\n      } else {\n        collector = [];\n      }\n\n      return collector;\n    }, []);\n    return out;\n  } // gets either a new object of the proper type or the last primitive value\n\n\n  function getOutputObject(shadows) {\n    var out;\n    var lastShadow = shadows[shadows.length - 1];\n\n    if (lastShadow instanceof Array) {\n      out = [];\n    } else if (lastShadow instanceof Function) {\n      try {\n        out = cloneFunction(lastShadow);\n      } catch (e) {\n        throw new Error(e.message);\n      }\n    } else if (lastShadow instanceof Object) {\n      out = {};\n    } else {\n      // lastShadow is a primitive value;\n      out = lastShadow;\n    }\n\n    return out;\n  } // checks for circular references\n\n\n  function circularReferenceCheck(shadows) {\n    // if any of the current objects to process exist in the queue\n    // then throw an error.\n    shadows.forEach(function (item) {\n      if (item instanceof Object && visited.indexOf(item) > -1) {\n        throw new Error('Circular reference error');\n      }\n    }); // if none of the current objects were in the queue\n    // then add references to the queue.\n\n    visited = visited.concat(shadows);\n  }\n\n  function objectMergeRecursor(shadows, currentDepth) {\n    if (options.depth !== false) {\n      currentDepth = currentDepth ? currentDepth + 1 : 1;\n    } else {\n      currentDepth = 0;\n    }\n\n    if (options.throwOnCircularRef === true) {\n      circularReferenceCheck(shadows);\n    }\n\n    var out = getOutputObject(shadows);\n    /*jslint unparam: true */\n\n    function shadowHandler(val, prop, shadow) {\n      if (out[prop]) {\n        out[prop] = objectMergeRecursor([out[prop], shadow[prop]], currentDepth);\n      } else {\n        out[prop] = objectMergeRecursor([shadow[prop]], currentDepth);\n      }\n    }\n    /*jslint unparam:false */\n\n\n    function shadowMerger(shadow) {\n      objectForeach(shadow, shadowHandler);\n    } // short circuits case where output would be a primitive value\n    // anyway.\n\n\n    if (out instanceof Object && currentDepth <= options.depth) {\n      // only merges trailing objects since primitives would wipe out\n      // previous objects, as in merging {a:'a'}, 'a', and {b:'b'}\n      // would result in {b:'b'} so the first two arguments\n      // can be ignored completely.\n      var relevantShadows = getShadowObjects(shadows);\n      relevantShadows.forEach(shadowMerger);\n    }\n\n    return out;\n  } // determines whether an options object was passed in and\n  // uses it if present\n  // ignore the jslint warning here too.\n\n\n  if (arguments[0] instanceof ObjectMergeOptions) {\n    options = arguments[0];\n    shadows = Array.prototype.slice.call(arguments, 1);\n  } else {\n    options = createOptions();\n    shadows = Array.prototype.slice.call(arguments, 0);\n  }\n\n  return objectMergeRecursor(shadows);\n}\n\nobjectMerge.createOptions = createOptions;\nmodule.exports = objectMerge;","map":{"version":3,"sources":["/Users/ivopascoal/Desktop/PeepoAvax/node_modules/object-merge/src/object-merge.js"],"names":["ObjectMergeOptions","opts","depth","throwOnCircularRef","createOptions","argz","Array","prototype","slice","call","arguments","unshift","F","bind","apply","objectMerge","shadows","objectForeach","require","cloneFunction","visited","options","getShadowObjects","out","reduce","collector","shadow","Object","push","getOutputObject","lastShadow","length","Function","e","Error","message","circularReferenceCheck","forEach","item","indexOf","concat","objectMergeRecursor","currentDepth","shadowHandler","val","prop","shadowMerger","relevantShadows","module","exports"],"mappings":"AAAA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,kBAAT,CAA4BC,IAA5B,EAAkC;AAC9B;;AACAA,EAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACA,OAAKC,KAAL,GAAaD,IAAI,CAACC,KAAL,IAAc,KAA3B,CAH8B,CAI9B;AACA;;AACA,OAAKC,kBAAL,GAA0B,wBAAwBF,IAAxB,IAAgCA,IAAI,CAACE,kBAAL,KAA4B,KAA5D,GAAoE,KAApE,GAA4E,IAAtG;AACH;AACD;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,aAAT,CAAuBH,IAAvB,EAA6B;AACzB;;AACA,MAAII,IAAI,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,EAAsC,CAAtC,CAAX;AACAL,EAAAA,IAAI,CAACM,OAAL,CAAa,IAAb;AACA,MAAIC,CAAC,GAAGZ,kBAAkB,CAACa,IAAnB,CAAwBC,KAAxB,CAA8Bd,kBAA9B,EAAkDK,IAAlD,CAAR;AACA,SAAO,IAAIO,CAAJ,EAAP;AACH;AACD;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,WAAT,CAAqBC,OAArB,EAA8B;AAC1B;;AACA,MAAIC,aAAa,GAAGC,OAAO,CAAC,gBAAD,CAA3B;;AACA,MAAIC,aAAa,GAAGD,OAAO,CAAC,gBAAD,CAA3B,CAH0B,CAI1B;;;AA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","sourcesContent":["/*\nLicense gpl-3.0 http://www.gnu.org/licenses/gpl-3.0-standalone.html\n*/\n/*jslint\n    white: true,\n    vars: true,\n    node: true\n*/\nfunction ObjectMergeOptions(opts) {\n    'use strict';\n    opts = opts || {};\n    this.depth = opts.depth || false;\n    // circular ref check is true unless explicitly set to false\n    // ignore the jslint warning here, it's pointless.\n    this.throwOnCircularRef = 'throwOnCircularRef' in opts && opts.throwOnCircularRef === false ? false : true;\n}\n/*jslint unparam:true*/\n/**\n * Creates a new options object suitable for use with objectMerge.\n * @memberOf objectMerge\n * @param {Object} [opts] An object specifying the options.\n * @param {Object} [opts.depth = false] Specifies the depth to traverse objects\n *  during merging. If this is set to false then there will be no depth limit.\n * @param {Object} [opts.throwOnCircularRef = true] Set to false to suppress\n *  errors on circular references.\n * @returns {ObjectMergeOptions} Returns an instance of ObjectMergeOptions\n *  to be used with objectMerge.\n * @example\n *  var opts = objectMerge.createOptions({\n *      depth : 2,\n *      throwOnCircularRef : false\n *  });\n *  var obj1 = {\n *      a1 : {\n *          a2 : {\n *              a3 : {}\n *          }\n *      }\n *  };\n *  var obj2 = {\n *      a1 : {\n *          a2 : {\n *              a3 : 'will not be in output'\n *          },\n *          a22 : {}\n *      }\n *  };\n *  objectMerge(opts, obj1, obj2);\n */\nfunction createOptions(opts) {\n    'use strict';\n    var argz = Array.prototype.slice.call(arguments, 0);\n    argz.unshift(null);\n    var F = ObjectMergeOptions.bind.apply(ObjectMergeOptions, argz);\n    return new F();\n}\n/*jslint unparam:false*/\n/**\n * Merges JavaScript objects recursively without altering the objects merged.\n * @namespace Merges JavaScript objects recursively without altering the objects merged.\n * @author <a href=\"mailto:matthewkastor@gmail.com\">Matthew Kastor</a>\n * @param {ObjectMergeOptions} [opts] An options object created by \n *  objectMerge.createOptions. Options must be specified as the first argument\n *  and must be an object created with createOptions or else the object will\n *  not be recognized as an options object and will be merged instead.\n * @param {Object} shadows [[shadows]...] One or more objects to merge. Each\n *  argument given will be treated as an object to merge. Each object\n *  overwrites the previous objects descendant properties if the property name\n *  matches. If objects properties are objects they will be merged recursively\n *  as well.\n * @returns {Object} Returns a single merged object composed from clones of the\n *  input objects.\n * @example\n *  var objectMerge = require('object-merge');\n *  var x = {\n *      a : 'a',\n *      b : 'b',\n *      c : {\n *          d : 'd',\n *          e : 'e',\n *          f : {\n *              g : 'g'\n *          }\n *      }\n *  };\n *  var y = {\n *      a : '`a',\n *      b : '`b',\n *      c : {\n *          d : '`d'\n *      }\n *  };\n *  var z = {\n *      a : {\n *          b : '``b'\n *      },\n *      fun : function foo () {\n *          return 'foo';\n *      },\n *      aps : Array.prototype.slice\n *  };\n *  var out = objectMerge(x, y, z);\n *  // out.a will be {\n *  //         b : '``b'\n *  //     }\n *  // out.b will be '`b'\n *  // out.c will be {\n *  //         d : '`d',\n *  //         e : 'e',\n *  //         f : {\n *  //             g : 'g'\n *  //         }\n *  //     }\n *  // out.fun will be a clone of z.fun\n *  // out.aps will be equal to z.aps\n */\nfunction objectMerge(shadows) {\n    'use strict';\n    var objectForeach = require('object-foreach');\n    var cloneFunction = require('clone-function');\n    // this is the queue of visited objects / properties.\n    var visited = [];\n    // various merge options\n    var options = {};\n    // gets the sequential trailing objects from array.\n    function getShadowObjects(shadows) {\n        var out = shadows.reduce(function (collector, shadow) {\n                if (shadow instanceof Object) {\n                    collector.push(shadow);\n                } else {\n                    collector = [];\n                }\n                return collector;\n            }, []);\n        return out;\n    }\n    // gets either a new object of the proper type or the last primitive value\n    function getOutputObject(shadows) {\n        var out;\n        var lastShadow = shadows[shadows.length - 1];\n        if (lastShadow instanceof Array) {\n            out = [];\n        } else if (lastShadow instanceof Function) {\n            try {\n                out = cloneFunction(lastShadow);\n            } catch (e) {\n                throw new Error(e.message);\n            }\n        } else if (lastShadow instanceof Object) {\n            out = {};\n        } else {\n            // lastShadow is a primitive value;\n            out = lastShadow;\n        }\n        return out;\n    }\n    // checks for circular references\n    function circularReferenceCheck(shadows) {\n        // if any of the current objects to process exist in the queue\n        // then throw an error.\n        shadows.forEach(function (item) {\n            if (item instanceof Object && visited.indexOf(item) > -1) {\n                throw new Error('Circular reference error');\n            }\n        });\n        // if none of the current objects were in the queue\n        // then add references to the queue.\n        visited = visited.concat(shadows);\n    }\n    function objectMergeRecursor(shadows, currentDepth) {\n        if (options.depth !== false) {\n            currentDepth = currentDepth ? currentDepth + 1 : 1;\n        } else {\n            currentDepth = 0;\n        }\n        if (options.throwOnCircularRef === true) {\n            circularReferenceCheck(shadows);\n        }\n        var out = getOutputObject(shadows);\n        /*jslint unparam: true */\n        function shadowHandler(val, prop, shadow) {\n            if (out[prop]) {\n                out[prop] = objectMergeRecursor([\n                    out[prop],\n                    shadow[prop]\n                ], currentDepth);\n            } else {\n                out[prop] = objectMergeRecursor([shadow[prop]], currentDepth);\n            }\n        }\n        /*jslint unparam:false */\n        function shadowMerger(shadow) {\n            objectForeach(shadow, shadowHandler);\n        }\n        // short circuits case where output would be a primitive value\n        // anyway.\n        if (out instanceof Object && currentDepth <= options.depth) {\n            // only merges trailing objects since primitives would wipe out\n            // previous objects, as in merging {a:'a'}, 'a', and {b:'b'}\n            // would result in {b:'b'} so the first two arguments\n            // can be ignored completely.\n            var relevantShadows = getShadowObjects(shadows);\n            relevantShadows.forEach(shadowMerger);\n        }\n        return out;\n    }\n    // determines whether an options object was passed in and\n    // uses it if present\n    // ignore the jslint warning here too.\n    if (arguments[0] instanceof ObjectMergeOptions) {\n        options = arguments[0];\n        shadows = Array.prototype.slice.call(arguments, 1);\n    } else {\n        options = createOptions();\n        shadows = Array.prototype.slice.call(arguments, 0);\n    }\n    return objectMergeRecursor(shadows);\n}\nobjectMerge.createOptions = createOptions;\nmodule.exports = objectMerge;"]},"metadata":{},"sourceType":"script"}