{"ast":null,"code":"import { FunctionFragment, Interface } from '@ethersproject/abi';\nconst MulticallAbi = [{\n  inputs: [{\n    components: [{\n      internalType: 'address',\n      name: 'target',\n      type: 'address'\n    }, {\n      internalType: 'bytes',\n      name: 'callData',\n      type: 'bytes'\n    }],\n    internalType: 'struct Multicall.Call[]',\n    name: 'calls',\n    type: 'tuple[]'\n  }],\n  name: 'aggregate',\n  outputs: [{\n    internalType: 'uint256',\n    name: 'blockNumber',\n    type: 'uint256'\n  }, {\n    internalType: 'bytes[]',\n    name: 'returnData',\n    type: 'bytes[]'\n  }],\n  stateMutability: 'nonpayable',\n  type: 'function'\n}, {\n  inputs: [{\n    internalType: 'uint256',\n    name: 'blockNumber',\n    type: 'uint256'\n  }],\n  name: 'getBlockHash',\n  outputs: [{\n    internalType: 'bytes32',\n    name: 'blockHash',\n    type: 'bytes32'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [],\n  name: 'getCurrentBlockCoinbase',\n  outputs: [{\n    internalType: 'address',\n    name: 'coinbase',\n    type: 'address'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [],\n  name: 'getCurrentBlockDifficulty',\n  outputs: [{\n    internalType: 'uint256',\n    name: 'difficulty',\n    type: 'uint256'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [],\n  name: 'getCurrentBlockGasLimit',\n  outputs: [{\n    internalType: 'uint256',\n    name: 'gaslimit',\n    type: 'uint256'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [],\n  name: 'getCurrentBlockTimestamp',\n  outputs: [{\n    internalType: 'uint256',\n    name: 'timestamp',\n    type: 'uint256'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [{\n    internalType: 'address',\n    name: 'addr',\n    type: 'address'\n  }],\n  name: 'getEthBalance',\n  outputs: [{\n    internalType: 'uint256',\n    name: 'balance',\n    type: 'uint256'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [],\n  name: 'getLastBlockHash',\n  outputs: [{\n    internalType: 'bytes32',\n    name: 'blockHash',\n    type: 'bytes32'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}];\n\nconst encodeCallData = call => {\n  const iface = call.contract ? call.contract.interface : new Interface([`function ${call.signature}`]);\n  const method = call.method || FunctionFragment.fromString(call.signature).name;\n  const callData = iface.encodeFunctionData(method, call.params || []);\n  return callData;\n};\n\nconst decodeReturnData = (call, data) => {\n  const iface = call.contract ? call.contract.interface : new Interface([`function ${call.signature}`]);\n  const method = call.method || FunctionFragment.fromString(call.signature).name;\n\n  try {\n    const result = iface.decodeFunctionResult(method, data);\n    return result;\n  } catch (e) {\n    var _call$contract;\n\n    console.warn('Can not decode result of call', {\n      address: call.target || ((_call$contract = call.contract) === null || _call$contract === void 0 ? void 0 : _call$contract.address),\n      method: call.signature || call.method\n    });\n    return [];\n  }\n};\n\nconst multicallInterface = new Interface(MulticallAbi);\nexport const multicall = async (provider, multicallAddress, calls) => {\n  if (!calls || !calls.length) {\n    return [];\n  }\n\n  const callData = calls.map(call => {\n    var _call$contract2;\n\n    console.log('caaaaaaaaaaa', call);\n    return [call.target || ((_call$contract2 = call.contract) === null || _call$contract2 === void 0 ? void 0 : _call$contract2.address), encodeCallData(call)];\n  });\n  const aggregateData = multicallInterface.encodeFunctionData('aggregate', [callData]);\n  console.log('multicall', multicallAddress, aggregateData);\n  const response = await provider.send('eth_call', [{\n    to: multicallAddress,\n    data: aggregateData\n  }, 'latest']);\n  const {\n    returnData\n  } = multicallInterface.decodeFunctionResult('aggregate', response);\n  return calls.map((call, index) => {\n    return decodeReturnData(call, returnData[index]);\n  });\n};","map":{"version":3,"sources":["/Users/ivopascoal/Desktop/cuffies/src/diamondhand/multicall.ts"],"names":["FunctionFragment","Interface","MulticallAbi","inputs","components","internalType","name","type","outputs","stateMutability","encodeCallData","call","iface","contract","interface","signature","method","fromString","callData","encodeFunctionData","params","decodeReturnData","data","result","decodeFunctionResult","e","console","warn","address","target","multicallInterface","multicall","provider","multicallAddress","calls","length","map","log","aggregateData","response","send","to","returnData","index"],"mappings":"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","sourcesContent":["import { FunctionFragment, Interface } from '@ethersproject/abi';\nimport { Contract } from '@ethersproject/contracts';\nimport { JsonRpcProvider } from '@ethersproject/providers';\n\nconst MulticallAbi = [\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: 'address', name: 'target', type: 'address' },\n          { internalType: 'bytes', name: 'callData', type: 'bytes' },\n        ],\n        internalType: 'struct Multicall.Call[]',\n        name: 'calls',\n        type: 'tuple[]',\n      },\n    ],\n    name: 'aggregate',\n    outputs: [\n      { internalType: 'uint256', name: 'blockNumber', type: 'uint256' },\n      { internalType: 'bytes[]', name: 'returnData', type: 'bytes[]' },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'uint256', name: 'blockNumber', type: 'uint256' }],\n    name: 'getBlockHash',\n    outputs: [{ internalType: 'bytes32', name: 'blockHash', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getCurrentBlockCoinbase',\n    outputs: [{ internalType: 'address', name: 'coinbase', type: 'address' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getCurrentBlockDifficulty',\n    outputs: [{ internalType: 'uint256', name: 'difficulty', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getCurrentBlockGasLimit',\n    outputs: [{ internalType: 'uint256', name: 'gaslimit', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getCurrentBlockTimestamp',\n    outputs: [{ internalType: 'uint256', name: 'timestamp', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'addr', type: 'address' }],\n    name: 'getEthBalance',\n    outputs: [{ internalType: 'uint256', name: 'balance', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getLastBlockHash',\n    outputs: [{ internalType: 'bytes32', name: 'blockHash', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n];\n\nexport type Call = {\n  contract?: Contract;\n  method?: string;\n  target?: string;\n  signature?: string;\n  params?: any[];\n};\n\nconst encodeCallData = (call: Call) => {\n  const iface = call.contract\n    ? call.contract.interface\n    : new Interface([`function ${call.signature}`]);\n  const method = call.method || FunctionFragment.fromString(call.signature).name;\n  const callData = iface.encodeFunctionData(method, call.params || []);\n  return callData;\n};\n\nconst decodeReturnData = (call: Call, data: any) => {\n  const iface = call.contract\n    ? call.contract.interface\n    : new Interface([`function ${call.signature}`]);\n  const method = call.method || FunctionFragment.fromString(call.signature).name;\n  try {\n    const result = iface.decodeFunctionResult(method, data);\n    return result as any[];\n  } catch (e) {\n    console.warn('Can not decode result of call', {\n      address: call.target || call.contract?.address,\n      method: call.signature || call.method,\n    });\n\n    return [];\n  }\n};\n\nconst multicallInterface = new Interface(MulticallAbi);\n\nexport const multicall = async (\n  provider: JsonRpcProvider,\n  multicallAddress: string,\n  calls: Call[],\n) => {\n  if (!calls || !calls.length) {\n    return [];\n  }\n  const callData = calls.map((call) => {\n    console.log('caaaaaaaaaaa', call);\n    return [call.target || call.contract?.address, encodeCallData(call)];\n  });\n  const aggregateData = multicallInterface.encodeFunctionData('aggregate', [callData]);\n\n  console.log('multicall', multicallAddress, aggregateData);\n  const response = await provider.send('eth_call', [\n    {\n      to: multicallAddress,\n      data: aggregateData,\n    },\n    'latest',\n  ]);\n  const { returnData } = multicallInterface.decodeFunctionResult('aggregate', response);\n\n  return calls.map((call, index) => {\n    return decodeReturnData(call, returnData[index]);\n  });\n};\n"]},"metadata":{},"sourceType":"module"}