{"ast":null,"code":"export function toPair(x) {\n  return Object.keys(x).map(key => ({\n    key,\n    value: x[key]\n  }));\n}\nexport function fromPairs(keys, values) {\n  if (!keys || !values) {\n    return {};\n  }\n\n  return keys.reduce((memo, current, index) => {\n    return { ...memo,\n      [current]: values[index]\n    };\n  }, {});\n}\nexport const mapObject = (source, mapper) => {\n  if (!source) {\n    return;\n  }\n\n  return Object.entries(source).reduce((memo, [key, value]) => ({ ...memo,\n    [key]: value ? mapper(value) : null\n  }), {});\n};\nexport const flatten = x => {\n  return x.reduce((ret, cur) => [...ret, ...cur], []);\n};\nexport const range = (start, end) => {\n  if (isNaN(start) || isNaN(end)) {\n    return;\n  }\n\n  const ret = [];\n\n  for (let index = start; index < end; index++) {\n    ret.push(index);\n  }\n\n  return ret;\n};\nexport const zipWith = (keys, value, mapper) => {\n  if (!keys || !value || keys.length !== value.length) {\n    throw 'length mismatch';\n  }\n\n  return keys.reduce((memo, key, index) => {\n    return { ...memo,\n      [key]: mapper(value[index])\n    };\n  }, {});\n};","map":{"version":3,"sources":["/Users/ivopascoal/Desktop/BabyPepe/src/utils/objects.ts"],"names":["toPair","x","Object","keys","map","key","value","fromPairs","values","reduce","memo","current","index","mapObject","source","mapper","entries","flatten","ret","cur","range","start","end","isNaN","push","zipWith","length"],"mappings":"AAAA,OAAO,SAASA,MAAT,CAAmBC,CAAnB,EAAyC;AAC9C,SAAOC,MAAM,CAACC,IAAP,CAAYF,CAAZ,EAAeG,GAAf,CAAoBC,GAAD,KAAU;AAClCA,IAAAA,GADkC;AAElCC,IAAAA,KAAK,EAAEL,CAAC,CAACI,GAAD;AAF0B,GAAV,CAAnB,CAAP;AAID;AAED,OAAO,SAASE,SAAT,CAAiDJ,IAAjD,EAA4DK,MAA5D,EAAuF;AAC5F,MAAI,CAACL,IAAD,IAAS,CAACK,MAAd,EAAsB;AACpB,WAAO,EAAP;AACD;;AACD,SAAOL,IAAI,CAACM,MAAL,CAAY,CAACC,IAAD,EAAOC,OAAP,EAAgBC,KAAhB,KAA0B;AAC3C,WAAO,EACL,GAAGF,IADE;AAEL,OAACC,OAAD,GAAWH,MAAM,CAACI,KAAD;AAFZ,KAAP;AAID,GALM,EAKJ,EALI,CAAP;AAMD;AAED,OAAO,MAAMC,SAAS,GAAG,CAAOC,MAAP,EAAkCC,MAAlC,KAA0D;AACjF,MAAI,CAACD,MAAL,EAAa;AACX;AACD;;AAED,SAAOZ,MAAM,CAACc,OAAP,CAAeF,MAAf,EAAuBL,MAAvB,CACL,CAACC,IAAD,EAAO,CAACL,GAAD,EAAMC,KAAN,CAAP,MAAyB,EACvB,GAAGI,IADoB;AAEvB,KAACL,GAAD,GAAOC,KAAK,GAAGS,MAAM,CAACT,KAAD,CAAT,GAAmB;AAFR,GAAzB,CADK,EAKL,EALK,CAAP;AAOD,CAZM;AAcP,OAAO,MAAMW,OAAO,GAAOhB,CAAJ,IAAiB;AACtC,SAAOA,CAAC,CAACQ,MAAF,CAAS,CAACS,GAAD,EAAMC,GAAN,KAAc,CAAC,GAAGD,GAAJ,EAAS,GAAGC,GAAZ,CAAvB,EAAyC,EAAzC,CAAP;AACD,CAFM;AAIP,OAAO,MAAMC,KAAK,GAAG,CAACC,KAAD,EAAgBC,GAAhB,KAAgC;AACnD,MAAIC,KAAK,CAACF,KAAD,CAAL,IAAgBE,KAAK,CAACD,GAAD,CAAzB,EAAgC;AAC9B;AACD;;AACD,QAAMJ,GAAa,GAAG,EAAtB;;AACA,OAAK,IAAIN,KAAK,GAAGS,KAAjB,EAAwBT,KAAK,GAAGU,GAAhC,EAAqCV,KAAK,EAA1C,EAA8C;AAC5CM,IAAAA,GAAG,CAACM,IAAJ,CAASZ,KAAT;AACD;;AAED,SAAOM,GAAP;AACD,CAVM;AAYP,OAAO,MAAMO,OAAO,GAAG,CACrBtB,IADqB,EAErBG,KAFqB,EAGrBS,MAHqB,KAIC;AACtB,MAAI,CAACZ,IAAD,IAAS,CAACG,KAAV,IAAmBH,IAAI,CAACuB,MAAL,KAAgBpB,KAAK,CAACoB,MAA7C,EAAqD;AACnD,UAAM,iBAAN;AACD;;AAED,SAAOvB,IAAI,CAACM,MAAL,CAAY,CAACC,IAAD,EAAOL,GAAP,EAAYO,KAAZ,KAAsB;AACvC,WAAO,EACL,GAAGF,IADE;AAEL,OAACL,GAAD,GAAOU,MAAM,CAACT,KAAK,CAACM,KAAD,CAAN;AAFR,KAAP;AAID,GALM,EAKJ,EALI,CAAP;AAMD,CAfM","sourcesContent":["export function toPair<T>(x: Record<string, T>) {\n  return Object.keys(x).map((key) => ({\n    key,\n    value: x[key],\n  }));\n}\n\nexport function fromPairs<T extends string | number, V>(keys: T[], values: V[]): Record<T, V> {\n  if (!keys || !values) {\n    return {} as Record<T, V>;\n  }\n  return keys.reduce((memo, current, index) => {\n    return {\n      ...memo,\n      [current]: values[index],\n    };\n  }, {} as Record<T, V>);\n}\n\nexport const mapObject = <T, V>(source: Record<string, T>, mapper: (x: T) => V) => {\n  if (!source) {\n    return;\n  }\n\n  return Object.entries(source).reduce(\n    (memo, [key, value]) => ({\n      ...memo,\n      [key]: value ? mapper(value) : null,\n    }),\n    {} as Record<string, V>,\n  );\n};\n\nexport const flatten = <T>(x: T[][]) => {\n  return x.reduce((ret, cur) => [...ret, ...cur], []);\n};\n\nexport const range = (start: number, end: number) => {\n  if (isNaN(start) || isNaN(end)) {\n    return;\n  }\n  const ret: number[] = [];\n  for (let index = start; index < end; index++) {\n    ret.push(index);\n  }\n\n  return ret;\n};\n\nexport const zipWith = <T, K>(\n  keys: string[],\n  value: T[],\n  mapper: (t: T) => K,\n): Record<string, K> => {\n  if (!keys || !value || keys.length !== value.length) {\n    throw 'length mismatch';\n  }\n\n  return keys.reduce((memo, key, index) => {\n    return {\n      ...memo,\n      [key]: mapper(value[index]),\n    };\n  }, {});\n};\n"]},"metadata":{},"sourceType":"module"}