{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/** @file filter.js\n * @authors:\n *   Jeffrey Wilcke <jeff@ethdev.com>\n *   Marek Kotewicz <marek@ethdev.com>\n *   Marian Oancea <marian@ethdev.com>\n *   Fabian Vogelsteller <fabian@ethdev.com>\n *   Gav Wood <g@ethdev.com>\n * @date 2014\n */\nvar formatters = require('./formatters');\n\nvar utils = require('../utils/utils');\n/**\n* Converts a given topic to a hex string, but also allows null values.\n*\n* @param {Mixed} value\n* @return {String}\n*/\n\n\nvar toTopic = function (value) {\n  if (value === null || typeof value === 'undefined') return null;\n  value = String(value);\n  if (value.indexOf('0x') === 0) return value;else return utils.fromUtf8(value);\n}; /// This method should be called on options object, to verify deprecated properties && lazy load dynamic ones\n/// @param should be string or object\n/// @returns options string or object\n\n\nvar getOptions = function (options, type) {\n  /*jshint maxcomplexity: 6 */\n  if (utils.isString(options)) {\n    return options;\n  }\n\n  options = options || {};\n\n  switch (type) {\n    case 'eth':\n      // make sure topics, get converted to hex\n      options.topics = options.topics || [];\n      options.topics = options.topics.map(function (topic) {\n        return utils.isArray(topic) ? topic.map(toTopic) : toTopic(topic);\n      });\n      return {\n        topics: options.topics,\n        from: options.from,\n        to: options.to,\n        address: options.address,\n        fromBlock: formatters.inputBlockNumberFormatter(options.fromBlock),\n        toBlock: formatters.inputBlockNumberFormatter(options.toBlock)\n      };\n\n    case 'shh':\n      return options;\n  }\n};\n/**\nAdds the callback and sets up the methods, to iterate over the results.\n\n@method getLogsAtStart\n@param {Object} self\n@param {function} callback\n*/\n\n\nvar getLogsAtStart = function (self, callback) {\n  // call getFilterLogs for the first watch callback start\n  if (!utils.isString(self.options)) {\n    self.get(function (err, messages) {\n      // don't send all the responses to all the watches again... just to self one\n      if (err) {\n        callback(err);\n      }\n\n      if (utils.isArray(messages)) {\n        messages.forEach(function (message) {\n          callback(null, message);\n        });\n      }\n    });\n  }\n};\n/**\nAdds the callback and sets up the methods, to iterate over the results.\n\n@method pollFilter\n@param {Object} self\n*/\n\n\nvar pollFilter = function (self) {\n  var onMessage = function (error, messages) {\n    if (error) {\n      return self.callbacks.forEach(function (callback) {\n        callback(error);\n      });\n    }\n\n    if (utils.isArray(messages)) {\n      messages.forEach(function (message) {\n        message = self.formatter ? self.formatter(message) : message;\n        self.callbacks.forEach(function (callback) {\n          callback(null, message);\n        });\n      });\n    }\n  };\n\n  self.requestManager.startPolling({\n    method: self.implementation.poll.call,\n    params: [self.filterId]\n  }, self.filterId, onMessage, self.stopWatching.bind(self));\n};\n\nvar Filter = function (options, type, requestManager, methods, formatter, callback, filterCreationErrorCallback) {\n  var self = this;\n  var implementation = {};\n  methods.forEach(function (method) {\n    method.setRequestManager(requestManager);\n    method.attachToObject(implementation);\n  });\n  this.requestManager = requestManager;\n  this.options = getOptions(options, type);\n  this.implementation = implementation;\n  this.filterId = null;\n  this.callbacks = [];\n  this.getLogsCallbacks = [];\n  this.pollFilters = [];\n  this.formatter = formatter;\n  this.implementation.newFilter(this.options, function (error, id) {\n    if (error) {\n      self.callbacks.forEach(function (cb) {\n        cb(error);\n      });\n\n      if (typeof filterCreationErrorCallback === 'function') {\n        filterCreationErrorCallback(error);\n      }\n    } else {\n      self.filterId = id; // check if there are get pending callbacks as a consequence\n      // of calling get() with filterId unassigned.\n\n      self.getLogsCallbacks.forEach(function (cb) {\n        self.get(cb);\n      });\n      self.getLogsCallbacks = []; // get filter logs for the already existing watch calls\n\n      self.callbacks.forEach(function (cb) {\n        getLogsAtStart(self, cb);\n      });\n      if (self.callbacks.length > 0) pollFilter(self); // start to watch immediately\n\n      if (typeof callback === 'function') {\n        return self.watch(callback);\n      }\n    }\n  });\n  return this;\n};\n\nFilter.prototype.watch = function (callback) {\n  this.callbacks.push(callback);\n\n  if (this.filterId) {\n    getLogsAtStart(this, callback);\n    pollFilter(this);\n  }\n\n  return this;\n};\n\nFilter.prototype.stopWatching = function (callback) {\n  this.requestManager.stopPolling(this.filterId);\n  this.callbacks = []; // remove filter async\n\n  if (callback) {\n    this.implementation.uninstallFilter(this.filterId, callback);\n  } else {\n    return this.implementation.uninstallFilter(this.filterId);\n  }\n};\n\nFilter.prototype.get = function (callback) {\n  var self = this;\n\n  if (utils.isFunction(callback)) {\n    if (this.filterId === null) {\n      // If filterId is not set yet, call it back\n      // when newFilter() assigns it.\n      this.getLogsCallbacks.push(callback);\n    } else {\n      this.implementation.getLogs(this.filterId, function (err, res) {\n        if (err) {\n          callback(err);\n        } else {\n          callback(null, res.map(function (log) {\n            return self.formatter ? self.formatter(log) : log;\n          }));\n        }\n      });\n    }\n  } else {\n    if (this.filterId === null) {\n      throw new Error('Filter ID Error: filter().get() can\\'t be chained synchronous, please provide a callback for the get() method.');\n    }\n\n    var logs = this.implementation.getLogs(this.filterId);\n    return logs.map(function (log) {\n      return self.formatter ? self.formatter(log) : log;\n    });\n  }\n\n  return this;\n};\n\nmodule.exports = Filter;","map":{"version":3,"sources":["/Users/ivopascoal/Desktop/PhysicalNFTs/node_modules/@0xproject/web3-wrapper/node_modules/web3/lib/web3/filter.js"],"names":["formatters","require","utils","toTopic","value","String","indexOf","fromUtf8","getOptions","options","type","isString","topics","map","topic","isArray","from","to","address","fromBlock","inputBlockNumberFormatter","toBlock","getLogsAtStart","self","callback","get","err","messages","forEach","message","pollFilter","onMessage","error","callbacks","formatter","requestManager","startPolling","method","implementation","poll","call","params","filterId","stopWatching","bind","Filter","methods","filterCreationErrorCallback","setRequestManager","attachToObject","getLogsCallbacks","pollFilters","newFilter","id","cb","length","watch","prototype","push","stopPolling","uninstallFilter","isFunction","getLogs","res","log","Error","logs","module","exports"],"mappings":"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","sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/** @file filter.js\n * @authors:\n *   Jeffrey Wilcke <jeff@ethdev.com>\n *   Marek Kotewicz <marek@ethdev.com>\n *   Marian Oancea <marian@ethdev.com>\n *   Fabian Vogelsteller <fabian@ethdev.com>\n *   Gav Wood <g@ethdev.com>\n * @date 2014\n */\n\nvar formatters = require('./formatters');\nvar utils = require('../utils/utils');\n\n/**\n* Converts a given topic to a hex string, but also allows null values.\n*\n* @param {Mixed} value\n* @return {String}\n*/\nvar toTopic = function(value){\n\n    if(value === null || typeof value === 'undefined')\n        return null;\n\n    value = String(value);\n\n    if(value.indexOf('0x') === 0)\n        return value;\n    else\n        return utils.fromUtf8(value);\n};\n\n/// This method should be called on options object, to verify deprecated properties && lazy load dynamic ones\n/// @param should be string or object\n/// @returns options string or object\nvar getOptions = function (options, type) {\n    /*jshint maxcomplexity: 6 */\n\n    if (utils.isString(options)) {\n        return options;\n    }\n\n    options = options || {};\n\n\n    switch(type) {\n        case 'eth':\n\n            // make sure topics, get converted to hex\n            options.topics = options.topics || [];\n            options.topics = options.topics.map(function(topic){\n                return (utils.isArray(topic)) ? topic.map(toTopic) : toTopic(topic);\n            });\n\n            return {\n                topics: options.topics,\n                from: options.from,\n                to: options.to,\n                address: options.address,\n                fromBlock: formatters.inputBlockNumberFormatter(options.fromBlock),\n                toBlock: formatters.inputBlockNumberFormatter(options.toBlock)\n            };\n        case 'shh':\n            return options;\n    }\n};\n\n/**\nAdds the callback and sets up the methods, to iterate over the results.\n\n@method getLogsAtStart\n@param {Object} self\n@param {function} callback\n*/\nvar getLogsAtStart = function(self, callback){\n    // call getFilterLogs for the first watch callback start\n    if (!utils.isString(self.options)) {\n        self.get(function (err, messages) {\n            // don't send all the responses to all the watches again... just to self one\n            if (err) {\n                callback(err);\n            }\n\n            if(utils.isArray(messages)) {\n                messages.forEach(function (message) {\n                    callback(null, message);\n                });\n            }\n        });\n    }\n};\n\n/**\nAdds the callback and sets up the methods, to iterate over the results.\n\n@method pollFilter\n@param {Object} self\n*/\nvar pollFilter = function(self) {\n\n    var onMessage = function (error, messages) {\n        if (error) {\n            return self.callbacks.forEach(function (callback) {\n                callback(error);\n            });\n        }\n\n        if(utils.isArray(messages)) {\n            messages.forEach(function (message) {\n                message = self.formatter ? self.formatter(message) : message;\n                self.callbacks.forEach(function (callback) {\n                    callback(null, message);\n                });\n            });\n        }\n    };\n\n    self.requestManager.startPolling({\n        method: self.implementation.poll.call,\n        params: [self.filterId],\n    }, self.filterId, onMessage, self.stopWatching.bind(self));\n\n};\n\nvar Filter = function (options, type, requestManager, methods, formatter, callback, filterCreationErrorCallback) {\n    var self = this;\n    var implementation = {};\n    methods.forEach(function (method) {\n        method.setRequestManager(requestManager);\n        method.attachToObject(implementation);\n    });\n    this.requestManager = requestManager;\n    this.options = getOptions(options, type);\n    this.implementation = implementation;\n    this.filterId = null;\n    this.callbacks = [];\n    this.getLogsCallbacks = [];\n    this.pollFilters = [];\n    this.formatter = formatter;\n    this.implementation.newFilter(this.options, function(error, id){\n        if(error) {\n            self.callbacks.forEach(function(cb){\n                cb(error);\n            });\n            if (typeof filterCreationErrorCallback === 'function') {\n              filterCreationErrorCallback(error);\n            }\n        } else {\n            self.filterId = id;\n\n            // check if there are get pending callbacks as a consequence\n            // of calling get() with filterId unassigned.\n            self.getLogsCallbacks.forEach(function (cb){\n                self.get(cb);\n            });\n            self.getLogsCallbacks = [];\n\n            // get filter logs for the already existing watch calls\n            self.callbacks.forEach(function(cb){\n                getLogsAtStart(self, cb);\n            });\n            if(self.callbacks.length > 0)\n                pollFilter(self);\n\n            // start to watch immediately\n            if(typeof callback === 'function') {\n                return self.watch(callback);\n            }\n        }\n    });\n\n    return this;\n};\n\nFilter.prototype.watch = function (callback) {\n    this.callbacks.push(callback);\n\n    if(this.filterId) {\n        getLogsAtStart(this, callback);\n        pollFilter(this);\n    }\n\n    return this;\n};\n\nFilter.prototype.stopWatching = function (callback) {\n    this.requestManager.stopPolling(this.filterId);\n    this.callbacks = [];\n    // remove filter async\n    if (callback) {\n        this.implementation.uninstallFilter(this.filterId, callback);\n    } else {\n        return this.implementation.uninstallFilter(this.filterId);\n    }\n};\n\nFilter.prototype.get = function (callback) {\n    var self = this;\n    if (utils.isFunction(callback)) {\n        if (this.filterId === null) {\n            // If filterId is not set yet, call it back\n            // when newFilter() assigns it.\n            this.getLogsCallbacks.push(callback);\n        } else {\n            this.implementation.getLogs(this.filterId, function(err, res){\n                if (err) {\n                    callback(err);\n                } else {\n                    callback(null, res.map(function (log) {\n                        return self.formatter ? self.formatter(log) : log;\n                    }));\n                }\n            });\n        }\n    } else {\n        if (this.filterId === null) {\n            throw new Error('Filter ID Error: filter().get() can\\'t be chained synchronous, please provide a callback for the get() method.');\n        }\n        var logs = this.implementation.getLogs(this.filterId);\n        return logs.map(function (log) {\n            return self.formatter ? self.formatter(log) : log;\n        });\n    }\n\n    return this;\n};\n\nmodule.exports = Filter;\n\n"]},"metadata":{},"sourceType":"script"}