{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [0, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar json_schemas_1 = require(\"@0xproject/json-schemas\");\n\nvar utils_1 = require(\"@0xproject/utils\");\n\nvar web3_wrapper_1 = require(\"@0xproject/web3-wrapper\");\n\nvar ethABI = require(\"ethereumjs-abi\");\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nvar _ = require(\"lodash\");\n\nvar types_1 = require(\"./types\");\n\nvar schemas_1 = require(\"./schemas\");\n\nvar assert_1 = require(\"./utils/assert\");\n\nvar constants_1 = require(\"./utils/constants\");\n\nvar decorators_1 = require(\"./utils/decorators\");\n\nvar signature_utils_1 = require(\"./utils/signature_utils\");\n\nvar utils_2 = require(\"./utils/utils\");\n\nvar wyvern_atomicizer_1 = require(\"./abi_gen/wyvern_atomicizer\");\n\nvar wyvern_d_a_o_1 = require(\"./abi_gen/wyvern_d_a_o\");\n\nvar wyvern_exchange_1 = require(\"./abi_gen/wyvern_exchange\");\n\nvar wyvern_proxy_registry_1 = require(\"./abi_gen/wyvern_proxy_registry\");\n\nvar wyvern_token_1 = require(\"./abi_gen/wyvern_token\");\n\nvar WyvernProtocol = function () {\n  function WyvernProtocol(provider, config) {\n    assert_1.assert.isWeb3Provider('provider', provider); // assert.doesConformToSchema('config', config, wyvernProtocolConfigSchema)\n\n    this._web3Wrapper = new web3_wrapper_1.Web3Wrapper(provider, {\n      gasPrice: config.gasPrice\n    });\n    var exchangeContractAddress = config.wyvernExchangeContractAddress || WyvernProtocol.getExchangeContractAddress(config.network);\n    this.wyvernExchange = new wyvern_exchange_1.WyvernExchangeContract(this._web3Wrapper.getContractInstance(constants_1.constants.EXCHANGE_ABI, exchangeContractAddress), {});\n    var proxyRegistryContractAddress = config.wyvernProxyRegistryContractAddress || WyvernProtocol.getProxyRegistryContractAddress(config.network);\n    this.wyvernProxyRegistry = new wyvern_proxy_registry_1.WyvernProxyRegistryContract(this._web3Wrapper.getContractInstance(constants_1.constants.PROXY_REGISTRY_ABI, proxyRegistryContractAddress), {});\n    var daoContractAddress = config.wyvernDAOContractAddress || WyvernProtocol.getDAOContractAddress(config.network);\n    this.wyvernDAO = new wyvern_d_a_o_1.WyvernDAOContract(this._web3Wrapper.getContractInstance(constants_1.constants.DAO_ABI, daoContractAddress), {});\n    var tokenContractAddress = config.wyvernTokenContractAddress || WyvernProtocol.getTokenContractAddress(config.network);\n    this.wyvernToken = new wyvern_token_1.WyvernTokenContract(this._web3Wrapper.getContractInstance(constants_1.constants.TOKEN_ABI, tokenContractAddress), {});\n    var atomicizerContractAddress = config.wyvernAtomicizerContractAddress || WyvernProtocol.getAtomicizerContractAddress(config.network);\n    this.wyvernAtomicizer = new wyvern_atomicizer_1.WyvernAtomicizerContract(this._web3Wrapper.getContractInstance(constants_1.constants.ATOMICIZER_ABI, atomicizerContractAddress), {});\n  }\n\n  WyvernProtocol.getExchangeContractAddress = function (network) {\n    return constants_1.constants.DEPLOYED[network].WyvernExchange;\n  };\n\n  WyvernProtocol.getProxyRegistryContractAddress = function (network) {\n    return constants_1.constants.DEPLOYED[network].WyvernProxyRegistry;\n  };\n\n  WyvernProtocol.getTokenContractAddress = function (network) {\n    return constants_1.constants.DEPLOYED[network].WyvernToken;\n  };\n\n  WyvernProtocol.getDAOContractAddress = function (network) {\n    return constants_1.constants.DEPLOYED[network].WyvernDAO;\n  };\n\n  WyvernProtocol.getAtomicizerContractAddress = function (network) {\n    return constants_1.constants.DEPLOYED[network].WyvernAtomicizer;\n  };\n\n  WyvernProtocol.getTokenTransferProxyAddress = function (network) {\n    return constants_1.constants.DEPLOYED[network].WyvernTokenTransferProxy;\n  };\n  /**\n   * Verifies that the elliptic curve signature `signature` was generated\n   * by signing `data` with the private key corresponding to the `signerAddress` address.\n   * @param   data          The hex encoded data signed by the supplied signature.\n   * @param   signature     An object containing the elliptic curve signature parameters.\n   * @param   signerAddress The hex encoded address that signed the data, producing the supplied signature.\n   * @return  Whether the signature is valid for the supplied signerAddress and data.\n   */\n\n\n  WyvernProtocol.isValidSignature = function (data, signature, signerAddress) {\n    assert_1.assert.isHexString('data', data);\n    assert_1.assert.doesConformToSchema('signature', signature, schemas_1.schemas.ecSignatureSchema);\n    assert_1.assert.isETHAddressHex('signerAddress', signerAddress);\n    var isValidSignature = signature_utils_1.signatureUtils.isValidSignature(data, signature, signerAddress);\n    return isValidSignature;\n  };\n  /**\n   * Generates a pseudo-random 256-bit salt.\n   * The salt can be included in an 0x order, ensuring that the order generates a unique orderHash\n   * and will not collide with other outstanding orders that are identical in all other parameters.\n   * @return  A pseudo-random 256-bit number that can be used as a salt.\n   */\n\n\n  WyvernProtocol.generatePseudoRandomSalt = function () {\n    // BigNumber.random returns a pseudo-random number between 0 & 1 with a passed in number of decimal places.\n    // Source: https://mikemcl.github.io/bignumber.js/#random\n    var randomNumber = utils_1.BigNumber.random(constants_1.constants.MAX_DIGITS_IN_UNSIGNED_256_INT);\n    var factor = new utils_1.BigNumber(10).pow(constants_1.constants.MAX_DIGITS_IN_UNSIGNED_256_INT - 1);\n    var salt = randomNumber.times(factor).round();\n    return salt;\n  };\n  /**\n   * Checks if the supplied hex encoded order hash is valid.\n   * Note: Valid means it has the expected format, not that an order with the orderHash exists.\n   * Use this method when processing orderHashes submitted as user input.\n   * @param   orderHash    Hex encoded orderHash.\n   * @return  Whether the supplied orderHash has the expected format.\n   */\n\n\n  WyvernProtocol.isValidOrderHash = function (orderHash) {\n    // Since this method can be called to check if any arbitrary string conforms to an orderHash's\n    // format, we only assert that we were indeed passed a string.\n    assert_1.assert.isString('orderHash', orderHash);\n    var schemaValidator = new json_schemas_1.SchemaValidator();\n    var isValidOrderHash = schemaValidator.validate(orderHash, schemas_1.schemas.orderHashSchema).valid;\n    return isValidOrderHash;\n  };\n  /**\n   * A unit amount is defined as the amount of a token above the specified decimal places (integer part).\n   * E.g: If a currency has 18 decimal places, 1e18 or one quintillion of the currency is equivalent\n   * to 1 unit.\n   * @param   amount      The amount in baseUnits that you would like converted to units.\n   * @param   decimals    The number of decimal places the unit amount has.\n   * @return  The amount in units.\n   */\n\n\n  WyvernProtocol.toUnitAmount = function (amount, decimals) {\n    assert_1.assert.isValidBaseUnitAmount('amount', amount);\n    assert_1.assert.isNumber('decimals', decimals);\n    var aUnit = new utils_1.BigNumber(10).pow(decimals);\n    var unit = amount.div(aUnit);\n    return unit;\n  };\n  /**\n   * A baseUnit is defined as the smallest denomination of a token. An amount expressed in baseUnits\n   * is the amount expressed in the smallest denomination.\n   * E.g: 1 unit of a token with 18 decimal places is expressed in baseUnits as 1000000000000000000\n   * @param   amount      The amount of units that you would like converted to baseUnits.\n   * @param   decimals    The number of decimal places the unit amount has.\n   * @return  The amount in baseUnits.\n   */\n\n\n  WyvernProtocol.toBaseUnitAmount = function (amount, decimals) {\n    assert_1.assert.isBigNumber('amount', amount);\n    assert_1.assert.isNumber('decimals', decimals);\n    var unit = new utils_1.BigNumber(10).pow(decimals);\n    var baseUnitAmount = amount.times(unit);\n    var hasDecimals = baseUnitAmount.decimalPlaces() !== 0;\n\n    if (hasDecimals) {\n      throw new Error(\"Invalid unit amount: \" + amount.toString() + \" - Too many decimal places\");\n    }\n\n    return baseUnitAmount;\n  };\n  /**\n   * Computes the orderHash for a supplied order.\n   * @param   order   An object that conforms to the Order or SignedOrder interface definitions.\n   * @return  The resulting orderHash from hashing the supplied order.\n   */\n\n\n  WyvernProtocol.getOrderHashHex = function (order) {\n    assert_1.assert.doesConformToSchema('order', order, schemas_1.schemas.orderSchema);\n    var orderHashHex = utils_2.utils.getOrderHashHex(order);\n    return orderHashHex;\n  };\n  /**\n   * Computes the assetHash for a supplied asset.\n   */\n\n\n  WyvernProtocol.getAssetHashHex = function (assetHash, schema) {\n    var assetHashHex = utils_2.utils.getAssetHashHex(assetHash, schema);\n    return assetHashHex;\n  };\n  /**\n   * Sets a new web3 provider for wyvernProtocol.js. Updating the provider will stop all\n   * subscriptions so you will need to re-subscribe to all events relevant to your app after this call.\n   * @param   provider    The Web3Provider you would like the wyvernProtocol.js library to use from now on.\n   * @param   networkId   The id of the network your provider is connected to\n   */\n\n\n  WyvernProtocol.prototype.setProvider = function (provider, networkId) {\n    this._web3Wrapper.setProvider(provider);\n\n    this.wyvernExchange._invalidateContractInstances();\n\n    this.wyvernExchange._setNetworkId(networkId);\n\n    this.wyvernProxyRegistry._invalidateContractInstance();\n\n    this.wyvernProxyRegistry._setNetworkId(networkId);\n  };\n  /**\n   * Get user Ethereum addresses available through the supplied web3 provider available for sending transactions.\n   * @return  An array of available user Ethereum addresses.\n   */\n\n\n  WyvernProtocol.prototype.getAvailableAddressesAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var availableAddresses;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._web3Wrapper.getAvailableAddressesAsync()];\n\n          case 1:\n            availableAddresses = _a.sent();\n            return [2\n            /*return*/\n            , availableAddresses];\n        }\n      });\n    });\n  };\n  /**\n   * Signs an orderHash and returns its elliptic curve signature.\n   * This method currently supports TestRPC, Geth and Parity above and below V1.6.6\n   * @param   orderHash       Hex encoded orderHash to sign.\n   * @param   signerAddress   The hex encoded Ethereum address you wish to sign it with. This address\n   *          must be available via the Web3.Provider supplied to wyvernProtocol.js.\n   * @return  An object containing the Elliptic curve signature parameters generated by signing the orderHash.\n   */\n\n\n  WyvernProtocol.prototype.signOrderHashAsync = function (orderHash, signerAddress) {\n    return __awaiter(this, void 0, void 0, function () {\n      var msgHashHex, nodeVersion, isParityNode, isTestRpc, orderHashBuff, msgHashBuff, signature, validVParamValues, ecSignatureVRS, isValidVRSSignature, ecSignatureRSV, isValidRSVSignature;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('orderHash', orderHash);\n            return [4\n            /*yield*/\n            , this._web3Wrapper.getNodeVersionAsync()];\n\n          case 1:\n            nodeVersion = _a.sent();\n            isParityNode = utils_2.utils.isParityNode(nodeVersion);\n            isTestRpc = utils_2.utils.isTestRpc(nodeVersion);\n\n            if (isParityNode || isTestRpc) {\n              // Parity and TestRpc nodes add the personalMessage prefix itself\n              msgHashHex = orderHash;\n            } else {\n              orderHashBuff = ethUtil.toBuffer(orderHash);\n              msgHashBuff = ethUtil.hashPersonalMessage(orderHashBuff);\n              msgHashHex = ethUtil.bufferToHex(msgHashBuff);\n            }\n\n            return [4\n            /*yield*/\n            , this._web3Wrapper.signTransactionAsync(signerAddress, msgHashHex)];\n\n          case 2:\n            signature = _a.sent();\n            validVParamValues = [27, 28];\n            ecSignatureVRS = signature_utils_1.signatureUtils.parseSignatureHexAsVRS(signature);\n\n            if (_.includes(validVParamValues, ecSignatureVRS.v)) {\n              isValidVRSSignature = WyvernProtocol.isValidSignature(orderHash, ecSignatureVRS, signerAddress);\n\n              if (isValidVRSSignature) {\n                return [2\n                /*return*/\n                , ecSignatureVRS];\n              }\n            }\n\n            ecSignatureRSV = signature_utils_1.signatureUtils.parseSignatureHexAsRSV(signature);\n\n            if (_.includes(validVParamValues, ecSignatureRSV.v)) {\n              isValidRSVSignature = WyvernProtocol.isValidSignature(orderHash, ecSignatureRSV, signerAddress);\n\n              if (isValidRSVSignature) {\n                return [2\n                /*return*/\n                , ecSignatureRSV];\n              }\n            }\n\n            throw new Error(types_1.WyvernProtocolError.InvalidSignature);\n        }\n      });\n    });\n  };\n  /**\n   * Waits for a transaction to be mined and returns the transaction receipt.\n   * @param   txHash            Transaction hash\n   * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n   * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n   * @return  Transaction receipt with decoded log args.\n   */\n\n\n  WyvernProtocol.prototype.awaitTransactionMinedAsync = function (txHash, pollingIntervalMs, timeoutMs) {\n    if (pollingIntervalMs === void 0) {\n      pollingIntervalMs = 1000;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      var timeoutExceeded, txReceiptPromise;\n      return __generator(this, function (_a) {\n        timeoutExceeded = false;\n\n        if (timeoutMs) {\n          setTimeout(function () {\n            return timeoutExceeded = true;\n          }, timeoutMs);\n        }\n\n        txReceiptPromise = new Promise(function (resolve, reject) {\n          var intervalId = utils_1.intervalUtils.setAsyncExcludingInterval(function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              var transactionReceipt, logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    if (timeoutExceeded) {\n                      utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                      return [2\n                      /*return*/\n                      , reject(types_1.WyvernProtocolError.TransactionMiningTimeout)];\n                    }\n\n                    return [4\n                    /*yield*/\n                    , this._web3Wrapper.getTransactionReceiptAsync(txHash)];\n\n                  case 1:\n                    transactionReceipt = _a.sent();\n\n                    if (!_.isNull(transactionReceipt)) {\n                      utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                      logsWithDecodedArgs = _.map(transactionReceipt.logs, this._abiDecoder.tryToDecodeLogOrNoop.bind(this._abiDecoder));\n                      transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, {\n                        logs: logsWithDecodedArgs\n                      });\n                      resolve(transactionReceiptWithDecodedLogArgs);\n                    }\n\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            });\n          }, pollingIntervalMs, function () {\n            return {};\n          });\n        });\n        return [2\n        /*return*/\n        , txReceiptPromise];\n      });\n    });\n  };\n\n  WyvernProtocol.NULL_ADDRESS = constants_1.constants.NULL_ADDRESS;\n  WyvernProtocol.MAX_UINT_256 = new utils_1.BigNumber(2).pow(256).sub(1);\n  /**\n   * Encodes the replacementPattern for a supplied ABI and replace kind\n   * @param   abi AnnotatedFunctionABI\n   * @param   replaceKind Parameter kind to replace\n   * @return  The resulting encoded replacementPattern\n   */\n\n  WyvernProtocol.encodeReplacementPattern = function (abi, replaceKind, encodeToBytes) {\n    if (replaceKind === void 0) {\n      replaceKind = types_1.FunctionInputKind.Replaceable;\n    }\n\n    if (encodeToBytes === void 0) {\n      encodeToBytes = true;\n    }\n\n    var output = [];\n    var data = [];\n    var dynamicOffset = abi.inputs.reduce(function (len, _a) {\n      var type = _a.type;\n      var match = type.match(/\\[(.+)\\]$/);\n      return len + (match ? parseInt(match[1], 10) * 32 : 32);\n    }, 0);\n    abi.inputs.map(function (_a) {\n      var kind = _a.kind,\n          type = _a.type,\n          value = _a.value;\n      return {\n        bitmask: kind === replaceKind ? 255 : 0,\n        type: ethABI.elementaryName(type),\n        value: value !== undefined ? value : WyvernProtocol.generateDefaultValue(type)\n      };\n    }).reduce(function (offset, _a) {\n      var bitmask = _a.bitmask,\n          type = _a.type,\n          value = _a.value; // The 0xff bytes in the mask select the replacement bytes. All other bytes are 0x00.\n\n      var cur = new Buffer(ethABI.encodeSingle(type, value).length).fill(bitmask);\n\n      if (ethABI.isDynamic(type)) {\n        if (bitmask) {\n          throw new Error('Replacement is not supported for dynamic parameters.');\n        }\n\n        output.push(new Buffer(ethABI.encodeSingle('uint256', dynamicOffset).length));\n        data.push(cur);\n        return offset + cur.length;\n      }\n\n      output.push(cur);\n      return offset;\n    }, dynamicOffset); // 4 initial bytes of 0x00 for the method hash.\n\n    var methodIdMask = new Buffer(4);\n    var mask = Buffer.concat([methodIdMask, Buffer.concat(output.concat(data))]);\n    return encodeToBytes ? \"0x\" + mask.toString('hex') : mask.map(function (b) {\n      return b ? 1 : 0;\n    }).join('');\n  };\n  /**\n   * Encodes the atomicized replacementPattern for a supplied ABI and replace kind\n   * @param   abis array of AnnotatedFunctionABI\n   * @param   replaceKind Parameter kind to replace\n   * @return  The resulting encoded replacementPattern\n   */\n\n\n  WyvernProtocol.encodeAtomicizedReplacementPattern = function (abis, replaceKind) {\n    if (replaceKind === void 0) {\n      replaceKind = types_1.FunctionInputKind.Replaceable;\n    }\n\n    var allowReplaceByte = '1';\n    var doNotAllowReplaceByte = '0';\n    /* Four bytes for method ID. */\n\n    var maskArr = [doNotAllowReplaceByte, doNotAllowReplaceByte, doNotAllowReplaceByte, doNotAllowReplaceByte];\n    var encodedUint256 = ethABI.encodeSingle(ethABI.elementaryName('uint256'), WyvernProtocol.generateDefaultValue('uint256'));\n    var dataLocationSize = encodedUint256.length;\n    var dynamicArgumentLengthSize = encodedUint256.length; // See https://solidity.readthedocs.io/en/develop/abi-spec.html#examples\n    // Prepare dymanic types to be passed in (they need locations of their data parts). 4 for addresses, values, calldata lengths, calldatas\n\n    maskArr.push(doNotAllowReplaceByte.repeat(dataLocationSize * 4)); // Length of addresses array\n\n    maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize)); // Addresses should not be replaced\n\n    var encoded = ethABI.encodeSingle(ethABI.elementaryName('address'), WyvernProtocol.generateDefaultValue('address'));\n    maskArr.push(doNotAllowReplaceByte.repeat(encoded.length * abis.length)); // Length of values array\n\n    maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize)); // Add the values...\n\n    encoded = ethABI.encodeSingle(ethABI.elementaryName('uint'), WyvernProtocol.generateDefaultValue('uint'));\n    maskArr.push(doNotAllowReplaceByte.repeat(encoded.length * abis.length)); // Length of calldata lengths array\n\n    maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize)); // ... and calldata lengths\n\n    maskArr.push(doNotAllowReplaceByte.repeat(encoded.length * abis.length)); // Length of replacementPatterns\n\n    maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize)); // Raw replacementPatterns\n\n    var replacementBytes = [];\n    abis.map(function (abi) {\n      var replacement = WyvernProtocol.encodeReplacementPattern(abi, replaceKind, false);\n      replacementBytes.push(replacement);\n    });\n    var concatenatedReplacementPatterns = replacementBytes.join('');\n    maskArr.push(concatenatedReplacementPatterns);\n\n    if (concatenatedReplacementPatterns.length % 32 !== 0) {\n      // Pad replacementPatterns to nearest multiple of 32\n      maskArr.push(doNotAllowReplaceByte.repeat(32 - concatenatedReplacementPatterns.length % 32));\n    }\n\n    var mask = maskArr.reduce(function (x, y) {\n      return x + y;\n    }, '');\n    var ret = [];\n    /* Encode into bytes. */\n\n    for (var _i = 0, mask_1 = mask; _i < mask_1.length; _i++) {\n      var char = mask_1[_i];\n      var byte = char === allowReplaceByte ? 255 : 0;\n      var buf = Buffer.alloc(1);\n      buf.writeUInt8(byte, 0);\n      ret.push(buf);\n    }\n\n    return '0x' + Buffer.concat(ret).toString('hex');\n  };\n  /**\n   * Computes the default value for a type\n   * @param type The ABI type to calculate a default value for\n   * @return The default value for that type\n   */\n\n\n  WyvernProtocol.generateDefaultValue = function (type) {\n    switch (type) {\n      case 'address':\n      case 'bytes20':\n        /* Null address is sometimes checked in transfer calls. */\n        // But we need to use 0x000 because bitwise XOR won't work if there's a 0 in the actual address, since it will be replaced as 1 OR 0 = 1\n        return '0x0000000000000000000000000000000000000000';\n\n      case 'bytes32':\n        return '0x0000000000000000000000000000000000000000000000000000000000000000';\n\n      case 'bool':\n        return false;\n\n      case 'int':\n      case 'uint':\n      case 'uint8':\n      case 'uint16':\n      case 'uint32':\n      case 'uint64':\n      case 'uint256':\n        return 0;\n\n      default:\n        throw new Error('Default value not yet implemented for type: ' + type);\n    }\n  };\n\n  __decorate([decorators_1.decorators.syncWyvernProtocolErrorHandler], WyvernProtocol, \"getOrderHashHex\", null);\n\n  return WyvernProtocol;\n}();\n\nexports.WyvernProtocol = WyvernProtocol;","map":{"version":3,"sources":["../src/wyvernProtocol.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar json_schemas_1 = require(\"@0xproject/json-schemas\");\nvar utils_1 = require(\"@0xproject/utils\");\nvar web3_wrapper_1 = require(\"@0xproject/web3-wrapper\");\nvar ethABI = require(\"ethereumjs-abi\");\nvar ethUtil = require(\"ethereumjs-util\");\nvar _ = require(\"lodash\");\nvar types_1 = require(\"./types\");\nvar schemas_1 = require(\"./schemas\");\nvar assert_1 = require(\"./utils/assert\");\nvar constants_1 = require(\"./utils/constants\");\nvar decorators_1 = require(\"./utils/decorators\");\nvar signature_utils_1 = require(\"./utils/signature_utils\");\nvar utils_2 = require(\"./utils/utils\");\nvar wyvern_atomicizer_1 = require(\"./abi_gen/wyvern_atomicizer\");\nvar wyvern_d_a_o_1 = require(\"./abi_gen/wyvern_d_a_o\");\nvar wyvern_exchange_1 = require(\"./abi_gen/wyvern_exchange\");\nvar wyvern_proxy_registry_1 = require(\"./abi_gen/wyvern_proxy_registry\");\nvar wyvern_token_1 = require(\"./abi_gen/wyvern_token\");\nvar WyvernProtocol = /** @class */ (function () {\n    function WyvernProtocol(provider, config) {\n        assert_1.assert.isWeb3Provider('provider', provider);\n        // assert.doesConformToSchema('config', config, wyvernProtocolConfigSchema)\n        this._web3Wrapper = new web3_wrapper_1.Web3Wrapper(provider, { gasPrice: config.gasPrice });\n        var exchangeContractAddress = config.wyvernExchangeContractAddress || WyvernProtocol.getExchangeContractAddress(config.network);\n        this.wyvernExchange = new wyvern_exchange_1.WyvernExchangeContract(this._web3Wrapper.getContractInstance(constants_1.constants.EXCHANGE_ABI, exchangeContractAddress), {});\n        var proxyRegistryContractAddress = config.wyvernProxyRegistryContractAddress || WyvernProtocol.getProxyRegistryContractAddress(config.network);\n        this.wyvernProxyRegistry = new wyvern_proxy_registry_1.WyvernProxyRegistryContract(this._web3Wrapper.getContractInstance(constants_1.constants.PROXY_REGISTRY_ABI, proxyRegistryContractAddress), {});\n        var daoContractAddress = config.wyvernDAOContractAddress || WyvernProtocol.getDAOContractAddress(config.network);\n        this.wyvernDAO = new wyvern_d_a_o_1.WyvernDAOContract(this._web3Wrapper.getContractInstance(constants_1.constants.DAO_ABI, daoContractAddress), {});\n        var tokenContractAddress = config.wyvernTokenContractAddress || WyvernProtocol.getTokenContractAddress(config.network);\n        this.wyvernToken = new wyvern_token_1.WyvernTokenContract(this._web3Wrapper.getContractInstance(constants_1.constants.TOKEN_ABI, tokenContractAddress), {});\n        var atomicizerContractAddress = config.wyvernAtomicizerContractAddress || WyvernProtocol.getAtomicizerContractAddress(config.network);\n        this.wyvernAtomicizer = new wyvern_atomicizer_1.WyvernAtomicizerContract(this._web3Wrapper.getContractInstance(constants_1.constants.ATOMICIZER_ABI, atomicizerContractAddress), {});\n    }\n    WyvernProtocol.getExchangeContractAddress = function (network) {\n        return constants_1.constants.DEPLOYED[network].WyvernExchange;\n    };\n    WyvernProtocol.getProxyRegistryContractAddress = function (network) {\n        return constants_1.constants.DEPLOYED[network].WyvernProxyRegistry;\n    };\n    WyvernProtocol.getTokenContractAddress = function (network) {\n        return constants_1.constants.DEPLOYED[network].WyvernToken;\n    };\n    WyvernProtocol.getDAOContractAddress = function (network) {\n        return constants_1.constants.DEPLOYED[network].WyvernDAO;\n    };\n    WyvernProtocol.getAtomicizerContractAddress = function (network) {\n        return constants_1.constants.DEPLOYED[network].WyvernAtomicizer;\n    };\n    WyvernProtocol.getTokenTransferProxyAddress = function (network) {\n        return constants_1.constants.DEPLOYED[network].WyvernTokenTransferProxy;\n    };\n    /**\n     * Verifies that the elliptic curve signature `signature` was generated\n     * by signing `data` with the private key corresponding to the `signerAddress` address.\n     * @param   data          The hex encoded data signed by the supplied signature.\n     * @param   signature     An object containing the elliptic curve signature parameters.\n     * @param   signerAddress The hex encoded address that signed the data, producing the supplied signature.\n     * @return  Whether the signature is valid for the supplied signerAddress and data.\n     */\n    WyvernProtocol.isValidSignature = function (data, signature, signerAddress) {\n        assert_1.assert.isHexString('data', data);\n        assert_1.assert.doesConformToSchema('signature', signature, schemas_1.schemas.ecSignatureSchema);\n        assert_1.assert.isETHAddressHex('signerAddress', signerAddress);\n        var isValidSignature = signature_utils_1.signatureUtils.isValidSignature(data, signature, signerAddress);\n        return isValidSignature;\n    };\n    /**\n     * Generates a pseudo-random 256-bit salt.\n     * The salt can be included in an 0x order, ensuring that the order generates a unique orderHash\n     * and will not collide with other outstanding orders that are identical in all other parameters.\n     * @return  A pseudo-random 256-bit number that can be used as a salt.\n     */\n    WyvernProtocol.generatePseudoRandomSalt = function () {\n        // BigNumber.random returns a pseudo-random number between 0 & 1 with a passed in number of decimal places.\n        // Source: https://mikemcl.github.io/bignumber.js/#random\n        var randomNumber = utils_1.BigNumber.random(constants_1.constants.MAX_DIGITS_IN_UNSIGNED_256_INT);\n        var factor = new utils_1.BigNumber(10).pow(constants_1.constants.MAX_DIGITS_IN_UNSIGNED_256_INT - 1);\n        var salt = randomNumber.times(factor).round();\n        return salt;\n    };\n    /**\n     * Checks if the supplied hex encoded order hash is valid.\n     * Note: Valid means it has the expected format, not that an order with the orderHash exists.\n     * Use this method when processing orderHashes submitted as user input.\n     * @param   orderHash    Hex encoded orderHash.\n     * @return  Whether the supplied orderHash has the expected format.\n     */\n    WyvernProtocol.isValidOrderHash = function (orderHash) {\n        // Since this method can be called to check if any arbitrary string conforms to an orderHash's\n        // format, we only assert that we were indeed passed a string.\n        assert_1.assert.isString('orderHash', orderHash);\n        var schemaValidator = new json_schemas_1.SchemaValidator();\n        var isValidOrderHash = schemaValidator.validate(orderHash, schemas_1.schemas.orderHashSchema).valid;\n        return isValidOrderHash;\n    };\n    /**\n     * A unit amount is defined as the amount of a token above the specified decimal places (integer part).\n     * E.g: If a currency has 18 decimal places, 1e18 or one quintillion of the currency is equivalent\n     * to 1 unit.\n     * @param   amount      The amount in baseUnits that you would like converted to units.\n     * @param   decimals    The number of decimal places the unit amount has.\n     * @return  The amount in units.\n     */\n    WyvernProtocol.toUnitAmount = function (amount, decimals) {\n        assert_1.assert.isValidBaseUnitAmount('amount', amount);\n        assert_1.assert.isNumber('decimals', decimals);\n        var aUnit = new utils_1.BigNumber(10).pow(decimals);\n        var unit = amount.div(aUnit);\n        return unit;\n    };\n    /**\n     * A baseUnit is defined as the smallest denomination of a token. An amount expressed in baseUnits\n     * is the amount expressed in the smallest denomination.\n     * E.g: 1 unit of a token with 18 decimal places is expressed in baseUnits as 1000000000000000000\n     * @param   amount      The amount of units that you would like converted to baseUnits.\n     * @param   decimals    The number of decimal places the unit amount has.\n     * @return  The amount in baseUnits.\n     */\n    WyvernProtocol.toBaseUnitAmount = function (amount, decimals) {\n        assert_1.assert.isBigNumber('amount', amount);\n        assert_1.assert.isNumber('decimals', decimals);\n        var unit = new utils_1.BigNumber(10).pow(decimals);\n        var baseUnitAmount = amount.times(unit);\n        var hasDecimals = baseUnitAmount.decimalPlaces() !== 0;\n        if (hasDecimals) {\n            throw new Error(\"Invalid unit amount: \" + amount.toString() + \" - Too many decimal places\");\n        }\n        return baseUnitAmount;\n    };\n    /**\n     * Computes the orderHash for a supplied order.\n     * @param   order   An object that conforms to the Order or SignedOrder interface definitions.\n     * @return  The resulting orderHash from hashing the supplied order.\n     */\n    WyvernProtocol.getOrderHashHex = function (order) {\n        assert_1.assert.doesConformToSchema('order', order, schemas_1.schemas.orderSchema);\n        var orderHashHex = utils_2.utils.getOrderHashHex(order);\n        return orderHashHex;\n    };\n    /**\n     * Computes the assetHash for a supplied asset.\n     */\n    WyvernProtocol.getAssetHashHex = function (assetHash, schema) {\n        var assetHashHex = utils_2.utils.getAssetHashHex(assetHash, schema);\n        return assetHashHex;\n    };\n    /**\n     * Sets a new web3 provider for wyvernProtocol.js. Updating the provider will stop all\n     * subscriptions so you will need to re-subscribe to all events relevant to your app after this call.\n     * @param   provider    The Web3Provider you would like the wyvernProtocol.js library to use from now on.\n     * @param   networkId   The id of the network your provider is connected to\n     */\n    WyvernProtocol.prototype.setProvider = function (provider, networkId) {\n        this._web3Wrapper.setProvider(provider);\n        this.wyvernExchange._invalidateContractInstances();\n        this.wyvernExchange._setNetworkId(networkId);\n        this.wyvernProxyRegistry._invalidateContractInstance();\n        this.wyvernProxyRegistry._setNetworkId(networkId);\n    };\n    /**\n     * Get user Ethereum addresses available through the supplied web3 provider available for sending transactions.\n     * @return  An array of available user Ethereum addresses.\n     */\n    WyvernProtocol.prototype.getAvailableAddressesAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var availableAddresses;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._web3Wrapper.getAvailableAddressesAsync()];\n                    case 1:\n                        availableAddresses = _a.sent();\n                        return [2 /*return*/, availableAddresses];\n                }\n            });\n        });\n    };\n    /**\n     * Signs an orderHash and returns its elliptic curve signature.\n     * This method currently supports TestRPC, Geth and Parity above and below V1.6.6\n     * @param   orderHash       Hex encoded orderHash to sign.\n     * @param   signerAddress   The hex encoded Ethereum address you wish to sign it with. This address\n     *          must be available via the Web3.Provider supplied to wyvernProtocol.js.\n     * @return  An object containing the Elliptic curve signature parameters generated by signing the orderHash.\n     */\n    WyvernProtocol.prototype.signOrderHashAsync = function (orderHash, signerAddress) {\n        return __awaiter(this, void 0, void 0, function () {\n            var msgHashHex, nodeVersion, isParityNode, isTestRpc, orderHashBuff, msgHashBuff, signature, validVParamValues, ecSignatureVRS, isValidVRSSignature, ecSignatureRSV, isValidRSVSignature;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isHexString('orderHash', orderHash);\n                        return [4 /*yield*/, this._web3Wrapper.getNodeVersionAsync()];\n                    case 1:\n                        nodeVersion = _a.sent();\n                        isParityNode = utils_2.utils.isParityNode(nodeVersion);\n                        isTestRpc = utils_2.utils.isTestRpc(nodeVersion);\n                        if (isParityNode || isTestRpc) {\n                            // Parity and TestRpc nodes add the personalMessage prefix itself\n                            msgHashHex = orderHash;\n                        }\n                        else {\n                            orderHashBuff = ethUtil.toBuffer(orderHash);\n                            msgHashBuff = ethUtil.hashPersonalMessage(orderHashBuff);\n                            msgHashHex = ethUtil.bufferToHex(msgHashBuff);\n                        }\n                        return [4 /*yield*/, this._web3Wrapper.signTransactionAsync(signerAddress, msgHashHex)];\n                    case 2:\n                        signature = _a.sent();\n                        validVParamValues = [27, 28];\n                        ecSignatureVRS = signature_utils_1.signatureUtils.parseSignatureHexAsVRS(signature);\n                        if (_.includes(validVParamValues, ecSignatureVRS.v)) {\n                            isValidVRSSignature = WyvernProtocol.isValidSignature(orderHash, ecSignatureVRS, signerAddress);\n                            if (isValidVRSSignature) {\n                                return [2 /*return*/, ecSignatureVRS];\n                            }\n                        }\n                        ecSignatureRSV = signature_utils_1.signatureUtils.parseSignatureHexAsRSV(signature);\n                        if (_.includes(validVParamValues, ecSignatureRSV.v)) {\n                            isValidRSVSignature = WyvernProtocol.isValidSignature(orderHash, ecSignatureRSV, signerAddress);\n                            if (isValidRSVSignature) {\n                                return [2 /*return*/, ecSignatureRSV];\n                            }\n                        }\n                        throw new Error(types_1.WyvernProtocolError.InvalidSignature);\n                }\n            });\n        });\n    };\n    /**\n     * Waits for a transaction to be mined and returns the transaction receipt.\n     * @param   txHash            Transaction hash\n     * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n     * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n     * @return  Transaction receipt with decoded log args.\n     */\n    WyvernProtocol.prototype.awaitTransactionMinedAsync = function (txHash, pollingIntervalMs, timeoutMs) {\n        if (pollingIntervalMs === void 0) { pollingIntervalMs = 1000; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            var timeoutExceeded, txReceiptPromise;\n            return __generator(this, function (_a) {\n                timeoutExceeded = false;\n                if (timeoutMs) {\n                    setTimeout(function () { return (timeoutExceeded = true); }, timeoutMs);\n                }\n                txReceiptPromise = new Promise(function (resolve, reject) {\n                    var intervalId = utils_1.intervalUtils.setAsyncExcludingInterval(function () { return __awaiter(_this, void 0, void 0, function () {\n                        var transactionReceipt, logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs;\n                        return __generator(this, function (_a) {\n                            switch (_a.label) {\n                                case 0:\n                                    if (timeoutExceeded) {\n                                        utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                                        return [2 /*return*/, reject(types_1.WyvernProtocolError.TransactionMiningTimeout)];\n                                    }\n                                    return [4 /*yield*/, this._web3Wrapper.getTransactionReceiptAsync(txHash)];\n                                case 1:\n                                    transactionReceipt = _a.sent();\n                                    if (!_.isNull(transactionReceipt)) {\n                                        utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                                        logsWithDecodedArgs = _.map(transactionReceipt.logs, this._abiDecoder.tryToDecodeLogOrNoop.bind(this._abiDecoder));\n                                        transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, { logs: logsWithDecodedArgs });\n                                        resolve(transactionReceiptWithDecodedLogArgs);\n                                    }\n                                    return [2 /*return*/];\n                            }\n                        });\n                    }); }, pollingIntervalMs, function () { return ({}); });\n                });\n                return [2 /*return*/, txReceiptPromise];\n            });\n        });\n    };\n    WyvernProtocol.NULL_ADDRESS = constants_1.constants.NULL_ADDRESS;\n    WyvernProtocol.MAX_UINT_256 = new utils_1.BigNumber(2).pow(256).sub(1);\n    /**\n     * Encodes the replacementPattern for a supplied ABI and replace kind\n     * @param   abi AnnotatedFunctionABI\n     * @param   replaceKind Parameter kind to replace\n     * @return  The resulting encoded replacementPattern\n     */\n    WyvernProtocol.encodeReplacementPattern = function (abi, replaceKind, encodeToBytes) {\n        if (replaceKind === void 0) { replaceKind = types_1.FunctionInputKind.Replaceable; }\n        if (encodeToBytes === void 0) { encodeToBytes = true; }\n        var output = [];\n        var data = [];\n        var dynamicOffset = abi.inputs.reduce(function (len, _a) {\n            var type = _a.type;\n            var match = type.match(/\\[(.+)\\]$/);\n            return len + (match ? parseInt(match[1], 10) * 32 : 32);\n        }, 0);\n        abi.inputs\n            .map(function (_a) {\n            var kind = _a.kind, type = _a.type, value = _a.value;\n            return ({\n                bitmask: kind === replaceKind ? 255 : 0,\n                type: ethABI.elementaryName(type),\n                value: value !== undefined ? value : WyvernProtocol.generateDefaultValue(type),\n            });\n        })\n            .reduce(function (offset, _a) {\n            var bitmask = _a.bitmask, type = _a.type, value = _a.value;\n            // The 0xff bytes in the mask select the replacement bytes. All other bytes are 0x00.\n            var cur = new Buffer(ethABI.encodeSingle(type, value).length).fill(bitmask);\n            if (ethABI.isDynamic(type)) {\n                if (bitmask) {\n                    throw new Error('Replacement is not supported for dynamic parameters.');\n                }\n                output.push(new Buffer(ethABI.encodeSingle('uint256', dynamicOffset).length));\n                data.push(cur);\n                return offset + cur.length;\n            }\n            output.push(cur);\n            return offset;\n        }, dynamicOffset);\n        // 4 initial bytes of 0x00 for the method hash.\n        var methodIdMask = new Buffer(4);\n        var mask = Buffer.concat([methodIdMask, Buffer.concat(output.concat(data))]);\n        return encodeToBytes ? \"0x\" + mask.toString('hex') : mask.map(function (b) { return b ? 1 : 0; }).join('');\n    };\n    /**\n     * Encodes the atomicized replacementPattern for a supplied ABI and replace kind\n     * @param   abis array of AnnotatedFunctionABI\n     * @param   replaceKind Parameter kind to replace\n     * @return  The resulting encoded replacementPattern\n     */\n    WyvernProtocol.encodeAtomicizedReplacementPattern = function (abis, replaceKind) {\n        if (replaceKind === void 0) { replaceKind = types_1.FunctionInputKind.Replaceable; }\n        var allowReplaceByte = '1';\n        var doNotAllowReplaceByte = '0';\n        /* Four bytes for method ID. */\n        var maskArr = [doNotAllowReplaceByte, doNotAllowReplaceByte,\n            doNotAllowReplaceByte, doNotAllowReplaceByte];\n        var encodedUint256 = ethABI.encodeSingle(ethABI.elementaryName('uint256'), WyvernProtocol.generateDefaultValue('uint256'));\n        var dataLocationSize = encodedUint256.length;\n        var dynamicArgumentLengthSize = encodedUint256.length;\n        // See https://solidity.readthedocs.io/en/develop/abi-spec.html#examples\n        // Prepare dymanic types to be passed in (they need locations of their data parts). 4 for addresses, values, calldata lengths, calldatas\n        maskArr.push(doNotAllowReplaceByte.repeat(dataLocationSize * 4));\n        // Length of addresses array\n        maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize));\n        // Addresses should not be replaced\n        var encoded = ethABI.encodeSingle(ethABI.elementaryName('address'), WyvernProtocol.generateDefaultValue('address'));\n        maskArr.push(doNotAllowReplaceByte.repeat(encoded.length * abis.length));\n        // Length of values array\n        maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize));\n        // Add the values...\n        encoded = ethABI.encodeSingle(ethABI.elementaryName('uint'), WyvernProtocol.generateDefaultValue('uint'));\n        maskArr.push(doNotAllowReplaceByte.repeat(encoded.length * abis.length));\n        // Length of calldata lengths array\n        maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize));\n        // ... and calldata lengths\n        maskArr.push(doNotAllowReplaceByte.repeat(encoded.length * abis.length));\n        // Length of replacementPatterns\n        maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize));\n        // Raw replacementPatterns\n        var replacementBytes = [];\n        abis.map(function (abi) {\n            var replacement = WyvernProtocol.encodeReplacementPattern(abi, replaceKind, false);\n            replacementBytes.push(replacement);\n        });\n        var concatenatedReplacementPatterns = replacementBytes.join('');\n        maskArr.push(concatenatedReplacementPatterns);\n        if (concatenatedReplacementPatterns.length % 32 !== 0) {\n            // Pad replacementPatterns to nearest multiple of 32\n            maskArr.push(doNotAllowReplaceByte.repeat(32 - concatenatedReplacementPatterns.length % 32));\n        }\n        var mask = maskArr.reduce(function (x, y) { return x + y; }, '');\n        var ret = [];\n        /* Encode into bytes. */\n        for (var _i = 0, mask_1 = mask; _i < mask_1.length; _i++) {\n            var char = mask_1[_i];\n            var byte = char === allowReplaceByte ? 255 : 0;\n            var buf = Buffer.alloc(1);\n            buf.writeUInt8(byte, 0);\n            ret.push(buf);\n        }\n        return '0x' + Buffer.concat(ret).toString('hex');\n    };\n    /**\n     * Computes the default value for a type\n     * @param type The ABI type to calculate a default value for\n     * @return The default value for that type\n     */\n    WyvernProtocol.generateDefaultValue = function (type) {\n        switch (type) {\n            case 'address':\n            case 'bytes20':\n                /* Null address is sometimes checked in transfer calls. */\n                // But we need to use 0x000 because bitwise XOR won't work if there's a 0 in the actual address, since it will be replaced as 1 OR 0 = 1\n                return '0x0000000000000000000000000000000000000000';\n            case 'bytes32':\n                return '0x0000000000000000000000000000000000000000000000000000000000000000';\n            case 'bool':\n                return false;\n            case 'int':\n            case 'uint':\n            case 'uint8':\n            case 'uint16':\n            case 'uint32':\n            case 'uint64':\n            case 'uint256':\n                return 0;\n            default:\n                throw new Error('Default value not yet implemented for type: ' + type);\n        }\n    };\n    __decorate([\n        decorators_1.decorators.syncWyvernProtocolErrorHandler\n    ], WyvernProtocol, \"getOrderHashHex\", null);\n    return WyvernProtocol;\n}());\nexports.WyvernProtocol = WyvernProtocol;\n//# sourceMappingURL=wyvernProtocol.js.map"]},"metadata":{},"sourceType":"script"}