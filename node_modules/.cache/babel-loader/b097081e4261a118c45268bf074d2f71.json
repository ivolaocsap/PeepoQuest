{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$();\n\nimport { useWeb3React } from '@web3-react/core';\nimport { useCallback, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { addTransaction, clearAllTransactions } from './actions';\n// helper that can take a ethers library transaction response and add it to the list of transactions\nexport function useTransactionAdder() {\n  _s();\n\n  const {\n    chainId,\n    account\n  } = useWeb3React();\n  const dispatch = useDispatch();\n  return useCallback((response, {\n    summary,\n    approval,\n    redemption\n  } = {}) => {\n    // if (!account) return;\n    if (!chainId) return;\n    const {\n      hash\n    } = response;\n\n    if (!hash) {\n      throw Error('No transaction hash found.');\n    }\n\n    dispatch(addTransaction({\n      hash,\n      from: account,\n      chainId,\n      approval,\n      summary,\n      redemption\n    }));\n  }, [dispatch, chainId, account]);\n} // returns all the transactions for the current chain\n\n_s(useTransactionAdder, \"LsI3QB4QjjPi430Htg01jjyDhLQ=\", false, function () {\n  return [useWeb3React, useDispatch];\n});\n\nexport function useAllTransactions() {\n  _s2();\n\n  var _state$chainId;\n\n  const {\n    chainId\n  } = useWeb3React();\n  const state = useSelector(state => state.transactions);\n  return chainId ? (_state$chainId = state[chainId]) !== null && _state$chainId !== void 0 ? _state$chainId : {} : {};\n}\n\n_s2(useAllTransactions, \"yLnGs1xbncNSFe5ba04UjoIq6Pg=\", false, function () {\n  return [useWeb3React, useSelector];\n});\n\nexport function useIsTransactionPending(transactionHash) {\n  _s3();\n\n  const transactions = useAllTransactions();\n\n  if (!transactionHash || !transactions[transactionHash]) {\n    return false;\n  }\n\n  return !transactions[transactionHash].receipt;\n}\n/**\n * Returns whether a transaction happened in the last day (86400 seconds * 1000 milliseconds / second)\n * @param tx to check for recency\n */\n\n_s3(useIsTransactionPending, \"hqz1TRfIl9I1+vK9TqtScGR9Kdg=\", false, function () {\n  return [useAllTransactions];\n});\n\nexport function isTransactionRecent(tx) {\n  return new Date().getTime() - tx.addedTime < 86400000;\n} // returns whether a token has a pending approval transaction\n\nexport function useHasPendingApproval(tokenAddress, spender) {\n  _s4();\n\n  const allTransactions = useAllTransactions();\n  return useMemo(() => typeof tokenAddress === 'string' && typeof spender === 'string' && Object.keys(allTransactions).some(hash => {\n    const tx = allTransactions[hash];\n    if (!tx) return false;\n\n    if (tx.receipt) {\n      return false;\n    } else {\n      const approval = tx.approval;\n      if (!approval) return false;\n      return approval.spender === spender && approval.tokenAddress === tokenAddress && isTransactionRecent(tx);\n    }\n  }), [allTransactions, spender, tokenAddress]);\n}\n\n_s4(useHasPendingApproval, \"VezVe/KwFqNDaRAkqywKb3KU5lg=\", false, function () {\n  return [useAllTransactions];\n});\n\nexport function useHasPendingRedemption(poolAddress) {\n  _s5();\n\n  const allTransactions = useAllTransactions();\n  return useMemo(() => typeof poolAddress === 'string' && Object.keys(allTransactions).some(hash => {\n    const tx = allTransactions[hash];\n\n    if (!tx || tx.receipt || !isTransactionRecent(tx)) {\n      return false;\n    }\n\n    const {\n      redemption\n    } = tx;\n\n    if (!redemption) {\n      return false;\n    }\n\n    return redemption.poolAddress === poolAddress;\n  }), [allTransactions, poolAddress]);\n}\n\n_s5(useHasPendingRedemption, \"VezVe/KwFqNDaRAkqywKb3KU5lg=\", false, function () {\n  return [useAllTransactions];\n});\n\nexport function useClearAllTransactions() {\n  _s6();\n\n  const {\n    chainId\n  } = useWeb3React();\n  const dispatch = useDispatch();\n  return {\n    clearAllTransactions: useCallback(() => dispatch(clearAllTransactions({\n      chainId\n    })), [chainId, dispatch])\n  };\n}\n\n_s6(useClearAllTransactions, \"gIdNFn72oD0nt5aiY+Zihu4Q614=\", false, function () {\n  return [useWeb3React, useDispatch];\n});","map":{"version":3,"sources":["/Users/ivopascoal/Desktop/BabyPepe/src/state/transactions/hooks.tsx"],"names":["useWeb3React","useCallback","useMemo","useDispatch","useSelector","addTransaction","clearAllTransactions","useTransactionAdder","chainId","account","dispatch","response","summary","approval","redemption","hash","Error","from","useAllTransactions","state","transactions","useIsTransactionPending","transactionHash","receipt","isTransactionRecent","tx","Date","getTime","addedTime","useHasPendingApproval","tokenAddress","spender","allTransactions","Object","keys","some","useHasPendingRedemption","poolAddress","useClearAllTransactions"],"mappings":"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","sourcesContent":["import { TransactionResponse } from '@ethersproject/providers';\nimport { useWeb3React } from '@web3-react/core';\nimport { useCallback, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\n\nimport { AppDispatch, AppState } from '../index';\nimport { addTransaction, clearAllTransactions } from './actions';\nimport { TransactionDetails } from './reducer';\n\nexport type TransactionCustomData = {\n  summary?: string;\n  approval?: { tokenAddress: string; spender: string };\n  redemption?: { poolAddress: string };\n  vault?: {\n    lock?: string;\n    claim?: string;\n  };\n};\n\n// helper that can take a ethers library transaction response and add it to the list of transactions\nexport function useTransactionAdder(): (\n  response: TransactionResponse,\n  customData?: TransactionCustomData,\n) => void {\n  const { chainId, account } = useWeb3React();\n  const dispatch = useDispatch<AppDispatch>();\n\n  return useCallback(\n    (\n      response: TransactionResponse,\n      { summary, approval, redemption }: TransactionCustomData = {},\n    ) => {\n      // if (!account) return;\n      if (!chainId) return;\n\n      const { hash } = response;\n      if (!hash) {\n        throw Error('No transaction hash found.');\n      }\n      dispatch(addTransaction({ hash, from: account, chainId, approval, summary, redemption }));\n    },\n    [dispatch, chainId, account],\n  );\n}\n\n// returns all the transactions for the current chain\nexport function useAllTransactions(): { [txHash: string]: TransactionDetails } {\n  const { chainId } = useWeb3React();\n  const state = useSelector<AppState, AppState['transactions']>((state) => state.transactions);\n\n  return chainId ? state[chainId] ?? {} : {};\n}\n\nexport function useIsTransactionPending(transactionHash?: string): boolean {\n  const transactions = useAllTransactions();\n  if (!transactionHash || !transactions[transactionHash]) {\n    return false;\n  }\n  return !transactions[transactionHash].receipt;\n}\n\n/**\n * Returns whether a transaction happened in the last day (86400 seconds * 1000 milliseconds / second)\n * @param tx to check for recency\n */\nexport function isTransactionRecent(tx: TransactionDetails): boolean {\n  return new Date().getTime() - tx.addedTime < 86_400_000;\n}\n\n// returns whether a token has a pending approval transaction\nexport function useHasPendingApproval(\n  tokenAddress: string | undefined,\n  spender: string | undefined,\n): boolean {\n  const allTransactions = useAllTransactions();\n\n  return useMemo(\n    () =>\n      typeof tokenAddress === 'string' &&\n      typeof spender === 'string' &&\n      Object.keys(allTransactions).some((hash) => {\n        const tx = allTransactions[hash];\n        if (!tx) return false;\n        if (tx.receipt) {\n          return false;\n        } else {\n          const approval = tx.approval;\n          if (!approval) return false;\n          return (\n            approval.spender === spender &&\n            approval.tokenAddress === tokenAddress &&\n            isTransactionRecent(tx)\n          );\n        }\n      }),\n    [allTransactions, spender, tokenAddress],\n  );\n}\n\nexport function useHasPendingRedemption(poolAddress: string | undefined): boolean {\n  const allTransactions = useAllTransactions();\n\n  return useMemo(\n    () =>\n      typeof poolAddress === 'string' &&\n      Object.keys(allTransactions).some((hash) => {\n        const tx = allTransactions[hash];\n        if (!tx || tx.receipt || !isTransactionRecent(tx)) {\n          return false;\n        }\n\n        const { redemption } = tx;\n        if (!redemption) {\n          return false;\n        }\n\n        return redemption.poolAddress === poolAddress;\n      }),\n    [allTransactions, poolAddress],\n  );\n}\n\nexport function useClearAllTransactions(): { clearAllTransactions: () => void } {\n  const { chainId } = useWeb3React();\n  const dispatch = useDispatch<AppDispatch>();\n  return {\n    clearAllTransactions: useCallback(() => dispatch(clearAllTransactions({ chainId })), [\n      chainId,\n      dispatch,\n    ]),\n  };\n}\n"]},"metadata":{},"sourceType":"module"}