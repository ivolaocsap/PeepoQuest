{"ast":null,"code":"import _toConsumableArray from\"/Users/ivopascoal/Desktop/cuffies/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _slicedToArray from\"/Users/ivopascoal/Desktop/cuffies/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _defineProperty from\"/Users/ivopascoal/Desktop/cuffies/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _objectSpread from\"/Users/ivopascoal/Desktop/cuffies/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";export function toPair(x){return Object.keys(x).map(function(key){return{key:key,value:x[key]};});}export function fromPairs(keys,values){if(!keys||!values){return{};}return keys.reduce(function(memo,current,index){return _objectSpread(_objectSpread({},memo),{},_defineProperty({},current,values[index]));},{});}export var mapObject=function mapObject(source,mapper){if(!source){return;}return Object.entries(source).reduce(function(memo,_ref){var _ref2=_slicedToArray(_ref,2),key=_ref2[0],value=_ref2[1];return _objectSpread(_objectSpread({},memo),{},_defineProperty({},key,value?mapper(value):null));},{});};export var flatten=function flatten(x){return x.reduce(function(ret,cur){return[].concat(_toConsumableArray(ret),_toConsumableArray(cur));},[]);};export var range=function range(start,end){if(isNaN(start)||isNaN(end)){return;}var ret=[];for(var index=start;index<end;index++){ret.push(index);}return ret;};export var zipWith=function zipWith(keys,value,mapper){if(!keys||!value||keys.length!==value.length){throw'length mismatch';}return keys.reduce(function(memo,key,index){return _objectSpread(_objectSpread({},memo),{},_defineProperty({},key,mapper(value[index])));},{});};","map":{"version":3,"sources":["/Users/ivopascoal/Desktop/cuffies/src/utils/objects.ts"],"names":["toPair","x","Object","keys","map","key","value","fromPairs","values","reduce","memo","current","index","mapObject","source","mapper","entries","flatten","ret","cur","range","start","end","isNaN","push","zipWith","length"],"mappings":"ymBAAA,MAAO,SAASA,CAAAA,MAAT,CAAmBC,CAAnB,CAAyC,CAC9C,MAAOC,CAAAA,MAAM,CAACC,IAAP,CAAYF,CAAZ,EAAeG,GAAf,CAAmB,SAACC,GAAD,QAAU,CAClCA,GAAG,CAAHA,GADkC,CAElCC,KAAK,CAAEL,CAAC,CAACI,GAAD,CAF0B,CAAV,EAAnB,CAAP,CAID,CAED,MAAO,SAASE,CAAAA,SAAT,CAAiDJ,IAAjD,CAA4DK,MAA5D,CAAuF,CAC5F,GAAI,CAACL,IAAD,EAAS,CAACK,MAAd,CAAsB,CACpB,MAAO,EAAP,CACD,CACD,MAAOL,CAAAA,IAAI,CAACM,MAAL,CAAY,SAACC,IAAD,CAAOC,OAAP,CAAgBC,KAAhB,CAA0B,CAC3C,sCACKF,IADL,wBAEGC,OAFH,CAEaH,MAAM,CAACI,KAAD,CAFnB,GAID,CALM,CAKJ,EALI,CAAP,CAMD,CAED,MAAO,IAAMC,CAAAA,SAAS,CAAG,QAAZA,CAAAA,SAAY,CAAOC,MAAP,CAAkCC,MAAlC,CAA0D,CACjF,GAAI,CAACD,MAAL,CAAa,CACX,OACD,CAED,MAAOZ,CAAAA,MAAM,CAACc,OAAP,CAAeF,MAAf,EAAuBL,MAAvB,CACL,SAACC,IAAD,wCAAQL,GAAR,UAAaC,KAAb,gDACKI,IADL,wBAEGL,GAFH,CAESC,KAAK,CAAGS,MAAM,CAACT,KAAD,CAAT,CAAmB,IAFjC,IADK,CAKL,EALK,CAAP,CAOD,CAZM,CAcP,MAAO,IAAMW,CAAAA,OAAO,CAAG,QAAVA,CAAAA,OAAU,CAAIhB,CAAJ,CAAiB,CACtC,MAAOA,CAAAA,CAAC,CAACQ,MAAF,CAAS,SAACS,GAAD,CAAMC,GAAN,qCAAkBD,GAAlB,qBAA0BC,GAA1B,IAAT,CAAyC,EAAzC,CAAP,CACD,CAFM,CAIP,MAAO,IAAMC,CAAAA,KAAK,CAAG,QAARA,CAAAA,KAAQ,CAACC,KAAD,CAAgBC,GAAhB,CAAgC,CACnD,GAAIC,KAAK,CAACF,KAAD,CAAL,EAAgBE,KAAK,CAACD,GAAD,CAAzB,CAAgC,CAC9B,OACD,CACD,GAAMJ,CAAAA,GAAa,CAAG,EAAtB,CACA,IAAK,GAAIN,CAAAA,KAAK,CAAGS,KAAjB,CAAwBT,KAAK,CAAGU,GAAhC,CAAqCV,KAAK,EAA1C,CAA8C,CAC5CM,GAAG,CAACM,IAAJ,CAASZ,KAAT,EACD,CAED,MAAOM,CAAAA,GAAP,CACD,CAVM,CAYP,MAAO,IAAMO,CAAAA,OAAO,CAAG,QAAVA,CAAAA,OAAU,CACrBtB,IADqB,CAErBG,KAFqB,CAGrBS,MAHqB,CAIC,CACtB,GAAI,CAACZ,IAAD,EAAS,CAACG,KAAV,EAAmBH,IAAI,CAACuB,MAAL,GAAgBpB,KAAK,CAACoB,MAA7C,CAAqD,CACnD,KAAM,iBAAN,CACD,CAED,MAAOvB,CAAAA,IAAI,CAACM,MAAL,CAAY,SAACC,IAAD,CAAOL,GAAP,CAAYO,KAAZ,CAAsB,CACvC,sCACKF,IADL,wBAEGL,GAFH,CAESU,MAAM,CAACT,KAAK,CAACM,KAAD,CAAN,CAFf,GAID,CALM,CAKJ,EALI,CAAP,CAMD,CAfM","sourcesContent":["export function toPair<T>(x: Record<string, T>) {\n  return Object.keys(x).map((key) => ({\n    key,\n    value: x[key],\n  }));\n}\n\nexport function fromPairs<T extends string | number, V>(keys: T[], values: V[]): Record<T, V> {\n  if (!keys || !values) {\n    return {} as Record<T, V>;\n  }\n  return keys.reduce((memo, current, index) => {\n    return {\n      ...memo,\n      [current]: values[index],\n    };\n  }, {} as Record<T, V>);\n}\n\nexport const mapObject = <T, V>(source: Record<string, T>, mapper: (x: T) => V) => {\n  if (!source) {\n    return;\n  }\n\n  return Object.entries(source).reduce(\n    (memo, [key, value]) => ({\n      ...memo,\n      [key]: value ? mapper(value) : null,\n    }),\n    {} as Record<string, V>,\n  );\n};\n\nexport const flatten = <T>(x: T[][]) => {\n  return x.reduce((ret, cur) => [...ret, ...cur], []);\n};\n\nexport const range = (start: number, end: number) => {\n  if (isNaN(start) || isNaN(end)) {\n    return;\n  }\n  const ret: number[] = [];\n  for (let index = start; index < end; index++) {\n    ret.push(index);\n  }\n\n  return ret;\n};\n\nexport const zipWith = <T, K>(\n  keys: string[],\n  value: T[],\n  mapper: (t: T) => K,\n): Record<string, K> => {\n  if (!keys || !value || keys.length !== value.length) {\n    throw 'length mismatch';\n  }\n\n  return keys.reduce((memo, key, index) => {\n    return {\n      ...memo,\n      [key]: mapper(value[index]),\n    };\n  }, {});\n};\n"]},"metadata":{},"sourceType":"module"}