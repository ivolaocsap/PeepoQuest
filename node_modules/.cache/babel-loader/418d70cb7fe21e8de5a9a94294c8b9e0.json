{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar types_1 = require(\"@0xproject/types\");\n\nvar _ = require(\"lodash\");\n\nvar Web3 = require(\"web3\");\n\nvar SolidityCoder = require(\"web3/lib/solidity/coder\");\n\nvar configured_bignumber_1 = require(\"./configured_bignumber\");\n\nvar AbiDecoder = function () {\n  function AbiDecoder(abiArrays) {\n    this._savedABIs = [];\n    this._methodIds = {};\n\n    _.forEach(abiArrays, this._addABI.bind(this));\n  }\n\n  AbiDecoder._padZeros = function (address) {\n    var formatted = address;\n\n    if (_.startsWith(formatted, '0x')) {\n      formatted = formatted.slice(2);\n    }\n\n    formatted = _.padStart(formatted, 40, '0');\n    return \"0x\" + formatted;\n  }; // This method can only decode logs from the 0x & ERC20 smart contracts\n\n\n  AbiDecoder.prototype.tryToDecodeLogOrNoop = function (log) {\n    var methodId = log.topics[0];\n    var event = this._methodIds[methodId];\n\n    if (_.isUndefined(event)) {\n      return log;\n    }\n\n    var logData = log.data;\n    var decodedParams = {};\n    var dataIndex = 0;\n    var topicsIndex = 1;\n\n    var nonIndexedInputs = _.filter(event.inputs, function (input) {\n      return !input.indexed;\n    });\n\n    var dataTypes = _.map(nonIndexedInputs, function (input) {\n      return input.type;\n    });\n\n    var decodedData = SolidityCoder.decodeParams(dataTypes, logData.slice('0x'.length));\n    var failedToDecode = false;\n\n    _.forEach(event.inputs, function (param) {\n      // Indexed parameters are stored in topics. Non-indexed ones in decodedData\n      var value = param.indexed ? log.topics[topicsIndex++] : decodedData[dataIndex++];\n\n      if (_.isUndefined(value)) {\n        failedToDecode = true;\n        return;\n      }\n\n      if (param.type === types_1.SolidityTypes.Address) {\n        value = AbiDecoder._padZeros(new configured_bignumber_1.BigNumber(value).toString(16));\n      } else if (param.type === types_1.SolidityTypes.Uint256 || param.type === types_1.SolidityTypes.Uint8 || param.type === types_1.SolidityTypes.Uint) {\n        value = new configured_bignumber_1.BigNumber(value);\n      }\n\n      decodedParams[param.name] = value;\n    });\n\n    if (failedToDecode) {\n      return log;\n    } else {\n      return __assign({}, log, {\n        event: event.name,\n        args: decodedParams\n      });\n    }\n  };\n\n  AbiDecoder.prototype._addABI = function (abiArray) {\n    var _this = this;\n\n    _.map(abiArray, function (abi) {\n      if (abi.type === types_1.AbiType.Event) {\n        var signature = abi.name + \"(\" + _.map(abi.inputs, function (input) {\n          return input.type;\n        }).join(',') + \")\";\n        var signatureHash = new Web3().sha3(signature);\n        _this._methodIds[signatureHash] = abi;\n      }\n    });\n\n    this._savedABIs = this._savedABIs.concat(abiArray);\n  };\n\n  return AbiDecoder;\n}();\n\nexports.AbiDecoder = AbiDecoder;","map":{"version":3,"sources":["../src/abi_decoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar types_1 = require(\"@0xproject/types\");\nvar _ = require(\"lodash\");\nvar Web3 = require(\"web3\");\nvar SolidityCoder = require(\"web3/lib/solidity/coder\");\nvar configured_bignumber_1 = require(\"./configured_bignumber\");\nvar AbiDecoder = /** @class */ (function () {\n    function AbiDecoder(abiArrays) {\n        this._savedABIs = [];\n        this._methodIds = {};\n        _.forEach(abiArrays, this._addABI.bind(this));\n    }\n    AbiDecoder._padZeros = function (address) {\n        var formatted = address;\n        if (_.startsWith(formatted, '0x')) {\n            formatted = formatted.slice(2);\n        }\n        formatted = _.padStart(formatted, 40, '0');\n        return \"0x\" + formatted;\n    };\n    // This method can only decode logs from the 0x & ERC20 smart contracts\n    AbiDecoder.prototype.tryToDecodeLogOrNoop = function (log) {\n        var methodId = log.topics[0];\n        var event = this._methodIds[methodId];\n        if (_.isUndefined(event)) {\n            return log;\n        }\n        var logData = log.data;\n        var decodedParams = {};\n        var dataIndex = 0;\n        var topicsIndex = 1;\n        var nonIndexedInputs = _.filter(event.inputs, function (input) { return !input.indexed; });\n        var dataTypes = _.map(nonIndexedInputs, function (input) { return input.type; });\n        var decodedData = SolidityCoder.decodeParams(dataTypes, logData.slice('0x'.length));\n        var failedToDecode = false;\n        _.forEach(event.inputs, function (param) {\n            // Indexed parameters are stored in topics. Non-indexed ones in decodedData\n            var value = param.indexed ? log.topics[topicsIndex++] : decodedData[dataIndex++];\n            if (_.isUndefined(value)) {\n                failedToDecode = true;\n                return;\n            }\n            if (param.type === types_1.SolidityTypes.Address) {\n                value = AbiDecoder._padZeros(new configured_bignumber_1.BigNumber(value).toString(16));\n            }\n            else if (param.type === types_1.SolidityTypes.Uint256 ||\n                param.type === types_1.SolidityTypes.Uint8 ||\n                param.type === types_1.SolidityTypes.Uint) {\n                value = new configured_bignumber_1.BigNumber(value);\n            }\n            decodedParams[param.name] = value;\n        });\n        if (failedToDecode) {\n            return log;\n        }\n        else {\n            return __assign({}, log, { event: event.name, args: decodedParams });\n        }\n    };\n    AbiDecoder.prototype._addABI = function (abiArray) {\n        var _this = this;\n        _.map(abiArray, function (abi) {\n            if (abi.type === types_1.AbiType.Event) {\n                var signature = abi.name + \"(\" + _.map(abi.inputs, function (input) { return input.type; }).join(',') + \")\";\n                var signatureHash = new Web3().sha3(signature);\n                _this._methodIds[signatureHash] = abi;\n            }\n        });\n        this._savedABIs = this._savedABIs.concat(abiArray);\n    };\n    return AbiDecoder;\n}());\nexports.AbiDecoder = AbiDecoder;\n//# sourceMappingURL=abi_decoder.js.map"]},"metadata":{},"sourceType":"script"}