{"ast":null,"code":"\"use strict\";\n/* Sourced from 0x.js */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nexports.signatureUtils = {\n  isValidSignature: function (data, signature, signerAddress) {\n    var dataBuff = ethUtil.toBuffer(data); // const msgHashBuff = ethUtil.hashPersonalMessage(dataBuff);\n\n    var msgHashBuff = dataBuff;\n\n    try {\n      var pubKey = ethUtil.ecrecover(msgHashBuff, signature.v, ethUtil.toBuffer(signature.r), ethUtil.toBuffer(signature.s));\n      var retrievedAddress = ethUtil.bufferToHex(ethUtil.pubToAddress(pubKey));\n      return retrievedAddress === signerAddress;\n    } catch (err) {\n      return false;\n    }\n  },\n  parseSignatureHexAsVRS: function (signatureHex) {\n    var signatureBuffer = ethUtil.toBuffer(signatureHex);\n    var v = signatureBuffer[0];\n\n    if (v < 27) {\n      v += 27;\n    }\n\n    var r = signatureBuffer.slice(1, 33);\n    var s = signatureBuffer.slice(33, 65);\n    var ecSignature = {\n      v: v,\n      r: ethUtil.bufferToHex(r),\n      s: ethUtil.bufferToHex(s)\n    };\n    return ecSignature;\n  },\n  parseSignatureHexAsRSV: function (signatureHex) {\n    var _a = ethUtil.fromRpcSig(signatureHex),\n        v = _a.v,\n        r = _a.r,\n        s = _a.s;\n\n    var ecSignature = {\n      v: v,\n      r: ethUtil.bufferToHex(r),\n      s: ethUtil.bufferToHex(s)\n    };\n    return ecSignature;\n  }\n};","map":{"version":3,"sources":["../../src/utils/signature_utils.ts"],"names":[],"mappings":";AAAA;;;;;;AAEA,IAAA,OAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAIa,OAAA,CAAA,cAAA,GAAiB;AAC1B,EAAA,gBAAgB,EAAhB,UAAiB,IAAjB,EAA+B,SAA/B,EAAuD,aAAvD,EAA4E;AACxE,QAAM,QAAQ,GAAG,OAAO,CAAC,QAAR,CAAiB,IAAjB,CAAjB,CADwE,CAExE;;AACA,QAAM,WAAW,GAAG,QAApB;;AACA,QAAI;AACA,UAAM,MAAM,GAAG,OAAO,CAAC,SAAR,CACX,WADW,EAEX,SAAS,CAAC,CAFC,EAGX,OAAO,CAAC,QAAR,CAAiB,SAAS,CAAC,CAA3B,CAHW,EAIX,OAAO,CAAC,QAAR,CAAiB,SAAS,CAAC,CAA3B,CAJW,CAAf;AAMA,UAAM,gBAAgB,GAAG,OAAO,CAAC,WAAR,CAAoB,OAAO,CAAC,YAAR,CAAqB,MAArB,CAApB,CAAzB;AACA,aAAO,gBAAgB,KAAK,aAA5B;AACH,KATD,CASE,OAAO,GAAP,EAAY;AACV,aAAO,KAAP;AACH;AACJ,GAjByB;AAkB1B,EAAA,sBAAsB,EAAtB,UAAuB,YAAvB,EAA2C;AACvC,QAAM,eAAe,GAAG,OAAO,CAAC,QAAR,CAAiB,YAAjB,CAAxB;AACA,QAAI,CAAC,GAAG,eAAe,CAAC,CAAD,CAAvB;;AACA,QAAI,CAAC,GAAG,EAAR,EAAY;AACR,MAAA,CAAC,IAAI,EAAL;AACH;;AACD,QAAM,CAAC,GAAG,eAAe,CAAC,KAAhB,CAAsB,CAAtB,EAAyB,EAAzB,CAAV;AACA,QAAM,CAAC,GAAG,eAAe,CAAC,KAAhB,CAAsB,EAAtB,EAA0B,EAA1B,CAAV;AACA,QAAM,WAAW,GAAgB;AAC7B,MAAA,CAAC,EAAA,CAD4B;AAE7B,MAAA,CAAC,EAAE,OAAO,CAAC,WAAR,CAAoB,CAApB,CAF0B;AAG7B,MAAA,CAAC,EAAE,OAAO,CAAC,WAAR,CAAoB,CAApB;AAH0B,KAAjC;AAKA,WAAO,WAAP;AACH,GAhCyB;AAiC1B,EAAA,sBAAsB,EAAtB,UAAuB,YAAvB,EAA2C;AACjC,QAAA,EAAA,GAAA,OAAA,CAAA,UAAA,CAAA,YAAA,CAAA;AAAA,QAAE,CAAA,GAAA,EAAA,CAAA,CAAF;AAAA,QAAK,CAAA,GAAA,EAAA,CAAA,CAAL;AAAA,QAAQ,CAAA,GAAA,EAAA,CAAA,CAAR;;AACN,QAAM,WAAW,GAAgB;AAC7B,MAAA,CAAC,EAAA,CAD4B;AAE7B,MAAA,CAAC,EAAE,OAAO,CAAC,WAAR,CAAoB,CAApB,CAF0B;AAG7B,MAAA,CAAC,EAAE,OAAO,CAAC,WAAR,CAAoB,CAApB;AAH0B,KAAjC;AAKA,WAAO,WAAP;AACH;AAzCyB,CAAjB","sourceRoot":"","sourcesContent":["\"use strict\";\n/* Sourced from 0x.js */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ethUtil = require(\"ethereumjs-util\");\nexports.signatureUtils = {\n    isValidSignature: function (data, signature, signerAddress) {\n        var dataBuff = ethUtil.toBuffer(data);\n        // const msgHashBuff = ethUtil.hashPersonalMessage(dataBuff);\n        var msgHashBuff = dataBuff;\n        try {\n            var pubKey = ethUtil.ecrecover(msgHashBuff, signature.v, ethUtil.toBuffer(signature.r), ethUtil.toBuffer(signature.s));\n            var retrievedAddress = ethUtil.bufferToHex(ethUtil.pubToAddress(pubKey));\n            return retrievedAddress === signerAddress;\n        }\n        catch (err) {\n            return false;\n        }\n    },\n    parseSignatureHexAsVRS: function (signatureHex) {\n        var signatureBuffer = ethUtil.toBuffer(signatureHex);\n        var v = signatureBuffer[0];\n        if (v < 27) {\n            v += 27;\n        }\n        var r = signatureBuffer.slice(1, 33);\n        var s = signatureBuffer.slice(33, 65);\n        var ecSignature = {\n            v: v,\n            r: ethUtil.bufferToHex(r),\n            s: ethUtil.bufferToHex(s),\n        };\n        return ecSignature;\n    },\n    parseSignatureHexAsRSV: function (signatureHex) {\n        var _a = ethUtil.fromRpcSig(signatureHex), v = _a.v, r = _a.r, s = _a.s;\n        var ecSignature = {\n            v: v,\n            r: ethUtil.bufferToHex(r),\n            s: ethUtil.bufferToHex(s),\n        };\n        return ecSignature;\n    },\n};\n//# sourceMappingURL=signature_utils.js.map"]},"metadata":{},"sourceType":"script"}