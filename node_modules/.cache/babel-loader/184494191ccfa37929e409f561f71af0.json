{"ast":null,"code":"var f = require('./formatters');\n\nvar SolidityParam = require('./param');\n/**\n * SolidityType prototype is used to encode/decode solidity params of certain type\n */\n\n\nvar SolidityType = function (config) {\n  this._inputFormatter = config.inputFormatter;\n  this._outputFormatter = config.outputFormatter;\n};\n/**\n * Should be used to determine if this SolidityType do match given name\n *\n * @method isType\n * @param {String} name\n * @return {Bool} true if type match this SolidityType, otherwise false\n */\n\n\nSolidityType.prototype.isType = function (name) {\n  throw \"this method should be overrwritten for type \" + name;\n};\n/**\n * Should be used to determine what is the length of static part in given type\n *\n * @method staticPartLength\n * @param {String} name\n * @return {Number} length of static part in bytes\n */\n\n\nSolidityType.prototype.staticPartLength = function (name) {\n  // If name isn't an array then treat it like a single element array.\n  return (this.nestedTypes(name) || ['[1]']).map(function (type) {\n    // the length of the nested array\n    return parseInt(type.slice(1, -1), 10) || 1;\n  }).reduce(function (previous, current) {\n    return previous * current; // all basic types are 32 bytes long\n  }, 32);\n};\n/**\n * Should be used to determine if type is dynamic array\n * eg:\n * \"type[]\" => true\n * \"type[4]\" => false\n *\n * @method isDynamicArray\n * @param {String} name\n * @return {Bool} true if the type is dynamic array\n */\n\n\nSolidityType.prototype.isDynamicArray = function (name) {\n  var nestedTypes = this.nestedTypes(name);\n  return !!nestedTypes && !nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);\n};\n/**\n * Should be used to determine if type is static array\n * eg:\n * \"type[]\" => false\n * \"type[4]\" => true\n *\n * @method isStaticArray\n * @param {String} name\n * @return {Bool} true if the type is static array\n */\n\n\nSolidityType.prototype.isStaticArray = function (name) {\n  var nestedTypes = this.nestedTypes(name);\n  return !!nestedTypes && !!nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);\n};\n/**\n * Should return length of static array\n * eg.\n * \"int[32]\" => 32\n * \"int256[14]\" => 14\n * \"int[2][3]\" => 3\n * \"int\" => 1\n * \"int[1]\" => 1\n * \"int[]\" => 1\n *\n * @method staticArrayLength\n * @param {String} name\n * @return {Number} static array length\n */\n\n\nSolidityType.prototype.staticArrayLength = function (name) {\n  var nestedTypes = this.nestedTypes(name);\n\n  if (nestedTypes) {\n    return parseInt(nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g) || 1);\n  }\n\n  return 1;\n};\n/**\n * Should return nested type\n * eg.\n * \"int[32]\" => \"int\"\n * \"int256[14]\" => \"int256\"\n * \"int[2][3]\" => \"int[2]\"\n * \"int\" => \"int\"\n * \"int[]\" => \"int\"\n *\n * @method nestedName\n * @param {String} name\n * @return {String} nested name\n */\n\n\nSolidityType.prototype.nestedName = function (name) {\n  // remove last [] in name\n  var nestedTypes = this.nestedTypes(name);\n\n  if (!nestedTypes) {\n    return name;\n  }\n\n  return name.substr(0, name.length - nestedTypes[nestedTypes.length - 1].length);\n};\n/**\n * Should return true if type has dynamic size by default\n * such types are \"string\", \"bytes\"\n *\n * @method isDynamicType\n * @param {String} name\n * @return {Bool} true if is dynamic, otherwise false\n */\n\n\nSolidityType.prototype.isDynamicType = function () {\n  return false;\n};\n/**\n * Should return array of nested types\n * eg.\n * \"int[2][3][]\" => [\"[2]\", \"[3]\", \"[]\"]\n * \"int[] => [\"[]\"]\n * \"int\" => null\n *\n * @method nestedTypes\n * @param {String} name\n * @return {Array} array of nested types\n */\n\n\nSolidityType.prototype.nestedTypes = function (name) {\n  // return list of strings eg. \"[]\", \"[3]\", \"[]\", \"[2]\"\n  return name.match(/(\\[[0-9]*\\])/g);\n};\n/**\n * Should be used to encode the value\n *\n * @method encode\n * @param {Object} value\n * @param {String} name\n * @return {String} encoded value\n */\n\n\nSolidityType.prototype.encode = function (value, name) {\n  var self = this;\n\n  if (this.isDynamicArray(name)) {\n    return function () {\n      var length = value.length; // in int\n\n      var nestedName = self.nestedName(name);\n      var result = [];\n      result.push(f.formatInputInt(length).encode());\n      value.forEach(function (v) {\n        result.push(self.encode(v, nestedName));\n      });\n      return result;\n    }();\n  } else if (this.isStaticArray(name)) {\n    return function () {\n      var length = self.staticArrayLength(name); // in int\n\n      var nestedName = self.nestedName(name);\n      var result = [];\n\n      for (var i = 0; i < length; i++) {\n        result.push(self.encode(value[i], nestedName));\n      }\n\n      return result;\n    }();\n  }\n\n  return this._inputFormatter(value, name).encode();\n};\n/**\n * Should be used to decode value from bytes\n *\n * @method decode\n * @param {String} bytes\n * @param {Number} offset in bytes\n * @param {String} name type name\n * @returns {Object} decoded value\n */\n\n\nSolidityType.prototype.decode = function (bytes, offset, name) {\n  var self = this;\n\n  if (this.isDynamicArray(name)) {\n    return function () {\n      var arrayOffset = parseInt('0x' + bytes.substr(offset * 2, 64)); // in bytes\n\n      var length = parseInt('0x' + bytes.substr(arrayOffset * 2, 64)); // in int\n\n      var arrayStart = arrayOffset + 32; // array starts after length; // in bytes\n\n      var nestedName = self.nestedName(name);\n      var nestedStaticPartLength = self.staticPartLength(nestedName); // in bytes\n\n      var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;\n      var result = [];\n\n      for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {\n        result.push(self.decode(bytes, arrayStart + i, nestedName));\n      }\n\n      return result;\n    }();\n  } else if (this.isStaticArray(name)) {\n    return function () {\n      var length = self.staticArrayLength(name); // in int\n\n      var arrayStart = offset; // in bytes\n\n      var nestedName = self.nestedName(name);\n      var nestedStaticPartLength = self.staticPartLength(nestedName); // in bytes\n\n      var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;\n      var result = [];\n\n      for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {\n        result.push(self.decode(bytes, arrayStart + i, nestedName));\n      }\n\n      return result;\n    }();\n  } else if (this.isDynamicType(name)) {\n    return function () {\n      var dynamicOffset = parseInt('0x' + bytes.substr(offset * 2, 64)); // in bytes\n\n      var length = parseInt('0x' + bytes.substr(dynamicOffset * 2, 64)); // in bytes\n\n      var roundedLength = Math.floor((length + 31) / 32); // in int\n\n      var param = new SolidityParam(bytes.substr(dynamicOffset * 2, (1 + roundedLength) * 64), 0);\n      return self._outputFormatter(param, name);\n    }();\n  }\n\n  var length = this.staticPartLength(name);\n  var param = new SolidityParam(bytes.substr(offset * 2, length * 2));\n  return this._outputFormatter(param, name);\n};\n\nmodule.exports = SolidityType;","map":{"version":3,"sources":["/Users/ivopascoal/Desktop/PhysicalNFTs/node_modules/opensea-js/node_modules/web3/lib/solidity/type.js"],"names":["f","require","SolidityParam","SolidityType","config","_inputFormatter","inputFormatter","_outputFormatter","outputFormatter","prototype","isType","name","staticPartLength","nestedTypes","map","type","parseInt","slice","reduce","previous","current","isDynamicArray","length","match","isStaticArray","staticArrayLength","nestedName","substr","isDynamicType","encode","value","self","result","push","formatInputInt","forEach","v","i","decode","bytes","offset","arrayOffset","arrayStart","nestedStaticPartLength","roundedNestedStaticPartLength","Math","floor","dynamicOffset","roundedLength","param","module","exports"],"mappings":"AAAA,IAAIA,CAAC,GAAGC,OAAO,CAAC,cAAD,CAAf;;AACA,IAAIC,aAAa,GAAGD,OAAO,CAAC,SAAD,CAA3B;AAEA;AACA;AACA;;;AACA,IAAIE,YAAY,GAAG,UAAUC,MAAV,EAAkB;AACjC,OAAKC,eAAL,GAAuBD,MAAM,CAACE,cAA9B;AACA,OAAKC,gBAAL,GAAwBH,MAAM,CAACI,eAA/B;AACH,CAHD;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAL,YAAY,CAACM,SAAb,CAAuBC,MAAvB,GAAgC,UAAUC,IAAV,EAAgB;AAC5C,QAAM,iDAAiDA,IAAvD;AACH,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAR,YAAY,CAACM,SAAb,CAAuBG,gBAAvB,GAA0C,UAAUD,IAAV,EAAgB;AACtD;AACA,SAAO,CAAC,KAAKE,WAAL,CAAiBF,IAAjB,KAA0B,CAAC,KAAD,CAA3B,EACFG,GADE,CACE,UAAUC,IAAV,EAAgB;AACjB;AACA,WAAOC,QAAQ,CAACD,IAAI,CAACE,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,CAAD,EAAoB,EAApB,CAAR,IAAmC,CAA1C;AACH,GAJE,EAKFC,MALE,CAKK,UAAUC,QAAV,EAAoBC,OAApB,EAA6B;AACjC,WAAOD,QAAQ,GAAGC,OAAlB,CADiC,CAErC;AACC,GARE,EAQA,EARA,CAAP;AASH,CAXD;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAjB,YAAY,CAACM,SAAb,CAAuBY,cAAvB,GAAwC,UAAUV,IAAV,EAAgB;AACpD,MAAIE,WAAW,GAAG,KAAKA,WAAL,CAAiBF,IAAjB,CAAlB;AACA,SAAO,CAAC,CAACE,WAAF,IAAiB,CAACA,WAAW,CAACA,WAAW,CAACS,MAAZ,GAAqB,CAAtB,CAAX,CAAoCC,KAApC,CAA0C,YAA1C,CAAzB;AACH,CAHD;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACApB,YAAY,CAACM,SAAb,CAAuBe,aAAvB,GAAuC,UAAUb,IAAV,EAAgB;AACnD,MAAIE,WAAW,GAAG,KAAKA,WAAL,CAAiBF,IAAjB,CAAlB;AACA,SAAO,CAAC,CAACE,WAAF,IAAiB,CAAC,CAACA,WAAW,CAACA,WAAW,CAACS,MAAZ,GAAqB,CAAtB,CAAX,CAAoCC,KAApC,CAA0C,YAA1C,CAA1B;AACH,CAHD;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACApB,YAAY,CAACM,SAAb,CAAuBgB,iBAAvB,GAA2C,UAAUd,IAAV,EAAgB;AACvD,MAAIE,WAAW,GAAG,KAAKA,WAAL,CAAiBF,IAAjB,CAAlB;;AACA,MAAIE,WAAJ,EAAiB;AACd,WAAOG,QAAQ,CAACH,WAAW,CAACA,WAAW,CAACS,MAAZ,GAAqB,CAAtB,CAAX,CAAoCC,KAApC,CAA0C,YAA1C,KAA2D,CAA5D,CAAf;AACF;;AACD,SAAO,CAAP;AACH,CAND;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACApB,YAAY,CAACM,SAAb,CAAuBiB,UAAvB,GAAoC,UAAUf,IAAV,EAAgB;AAChD;AACA,MAAIE,WAAW,GAAG,KAAKA,WAAL,CAAiBF,IAAjB,CAAlB;;AACA,MAAI,CAACE,WAAL,EAAkB;AACd,WAAOF,IAAP;AACH;;AAED,SAAOA,IAAI,CAACgB,MAAL,CAAY,CAAZ,EAAehB,IAAI,CAACW,MAAL,GAAcT,WAAW,CAACA,WAAW,CAACS,MAAZ,GAAqB,CAAtB,CAAX,CAAoCA,MAAjE,CAAP;AACH,CARD;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAnB,YAAY,CAACM,SAAb,CAAuBmB,aAAvB,GAAuC,YAAY;AAC/C,SAAO,KAAP;AACH,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAzB,YAAY,CAACM,SAAb,CAAuBI,WAAvB,GAAqC,UAAUF,IAAV,EAAgB;AACjD;AACA,SAAOA,IAAI,CAACY,KAAL,CAAW,eAAX,CAAP;AACH,CAHD;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACApB,YAAY,CAACM,SAAb,CAAuBoB,MAAvB,GAAgC,UAAUC,KAAV,EAAiBnB,IAAjB,EAAuB;AACnD,MAAIoB,IAAI,GAAG,IAAX;;AACA,MAAI,KAAKV,cAAL,CAAoBV,IAApB,CAAJ,EAA+B;AAE3B,WAAQ,YAAY;AAChB,UAAIW,MAAM,GAAGQ,KAAK,CAACR,MAAnB,CADgB,CACoC;;AACpD,UAAII,UAAU,GAAGK,IAAI,CAACL,UAAL,CAAgBf,IAAhB,CAAjB;AAEA,UAAIqB,MAAM,GAAG,EAAb;AACAA,MAAAA,MAAM,CAACC,IAAP,CAAYjC,CAAC,CAACkC,cAAF,CAAiBZ,MAAjB,EAAyBO,MAAzB,EAAZ;AAEAC,MAAAA,KAAK,CAACK,OAAN,CAAc,UAAUC,CAAV,EAAa;AACvBJ,QAAAA,MAAM,CAACC,IAAP,CAAYF,IAAI,CAACF,MAAL,CAAYO,CAAZ,EAAeV,UAAf,CAAZ;AACH,OAFD;AAIA,aAAOM,MAAP;AACH,KAZM,EAAP;AAcH,GAhBD,MAgBO,IAAI,KAAKR,aAAL,CAAmBb,IAAnB,CAAJ,EAA8B;AAEjC,WAAQ,YAAY;AAChB,UAAIW,MAAM,GAAGS,IAAI,CAACN,iBAAL,CAAuBd,IAAvB,CAAb,CADgB,CACoC;;AACpD,UAAIe,UAAU,GAAGK,IAAI,CAACL,UAAL,CAAgBf,IAAhB,CAAjB;AAEA,UAAIqB,MAAM,GAAG,EAAb;;AACA,WAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGf,MAApB,EAA4Be,CAAC,EAA7B,EAAiC;AAC7BL,QAAAA,MAAM,CAACC,IAAP,CAAYF,IAAI,CAACF,MAAL,CAAYC,KAAK,CAACO,CAAD,CAAjB,EAAsBX,UAAtB,CAAZ;AACH;;AAED,aAAOM,MAAP;AACH,KAVM,EAAP;AAYH;;AAED,SAAO,KAAK3B,eAAL,CAAqByB,KAArB,EAA4BnB,IAA5B,EAAkCkB,MAAlC,EAAP;AACH,CAnCD;AAqCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA1B,YAAY,CAACM,SAAb,CAAuB6B,MAAvB,GAAgC,UAAUC,KAAV,EAAiBC,MAAjB,EAAyB7B,IAAzB,EAA+B;AAC3D,MAAIoB,IAAI,GAAG,IAAX;;AAEA,MAAI,KAAKV,cAAL,CAAoBV,IAApB,CAAJ,EAA+B;AAE3B,WAAQ,YAAY;AAChB,UAAI8B,WAAW,GAAGzB,QAAQ,CAAC,OAAOuB,KAAK,CAACZ,MAAN,CAAaa,MAAM,GAAG,CAAtB,EAAyB,EAAzB,CAAR,CAA1B,CADgB,CACiD;;AACjE,UAAIlB,MAAM,GAAGN,QAAQ,CAAC,OAAOuB,KAAK,CAACZ,MAAN,CAAac,WAAW,GAAG,CAA3B,EAA8B,EAA9B,CAAR,CAArB,CAFgB,CAEiD;;AACjE,UAAIC,UAAU,GAAGD,WAAW,GAAG,EAA/B,CAHgB,CAGmB;;AAEnC,UAAIf,UAAU,GAAGK,IAAI,CAACL,UAAL,CAAgBf,IAAhB,CAAjB;AACA,UAAIgC,sBAAsB,GAAGZ,IAAI,CAACnB,gBAAL,CAAsBc,UAAtB,CAA7B,CANgB,CAMiD;;AACjE,UAAIkB,6BAA6B,GAAGC,IAAI,CAACC,KAAL,CAAW,CAACH,sBAAsB,GAAG,EAA1B,IAAgC,EAA3C,IAAiD,EAArF;AACA,UAAIX,MAAM,GAAG,EAAb;;AAEA,WAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGf,MAAM,GAAGsB,6BAA7B,EAA4DP,CAAC,IAAIO,6BAAjE,EAAgG;AAC5FZ,QAAAA,MAAM,CAACC,IAAP,CAAYF,IAAI,CAACO,MAAL,CAAYC,KAAZ,EAAmBG,UAAU,GAAGL,CAAhC,EAAmCX,UAAnC,CAAZ;AACH;;AAED,aAAOM,MAAP;AACH,KAfM,EAAP;AAiBH,GAnBD,MAmBO,IAAI,KAAKR,aAAL,CAAmBb,IAAnB,CAAJ,EAA8B;AAEjC,WAAQ,YAAY;AAChB,UAAIW,MAAM,GAAGS,IAAI,CAACN,iBAAL,CAAuBd,IAAvB,CAAb,CADgB,CACgD;;AAChE,UAAI+B,UAAU,GAAGF,MAAjB,CAFgB,CAEgD;;AAEhE,UAAId,UAAU,GAAGK,IAAI,CAACL,UAAL,CAAgBf,IAAhB,CAAjB;AACA,UAAIgC,sBAAsB,GAAGZ,IAAI,CAACnB,gBAAL,CAAsBc,UAAtB,CAA7B,CALgB,CAKgD;;AAChE,UAAIkB,6BAA6B,GAAGC,IAAI,CAACC,KAAL,CAAW,CAACH,sBAAsB,GAAG,EAA1B,IAAgC,EAA3C,IAAiD,EAArF;AACA,UAAIX,MAAM,GAAG,EAAb;;AAEA,WAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGf,MAAM,GAAGsB,6BAA7B,EAA4DP,CAAC,IAAIO,6BAAjE,EAAgG;AAC5FZ,QAAAA,MAAM,CAACC,IAAP,CAAYF,IAAI,CAACO,MAAL,CAAYC,KAAZ,EAAmBG,UAAU,GAAGL,CAAhC,EAAmCX,UAAnC,CAAZ;AACH;;AAED,aAAOM,MAAP;AACH,KAdM,EAAP;AAeH,GAjBM,MAiBA,IAAI,KAAKJ,aAAL,CAAmBjB,IAAnB,CAAJ,EAA8B;AAEjC,WAAQ,YAAY;AAChB,UAAIoC,aAAa,GAAG/B,QAAQ,CAAC,OAAOuB,KAAK,CAACZ,MAAN,CAAaa,MAAM,GAAG,CAAtB,EAAyB,EAAzB,CAAR,CAA5B,CADgB,CACwD;;AACxE,UAAIlB,MAAM,GAAGN,QAAQ,CAAC,OAAOuB,KAAK,CAACZ,MAAN,CAAaoB,aAAa,GAAG,CAA7B,EAAgC,EAAhC,CAAR,CAArB,CAFgB,CAEwD;;AACxE,UAAIC,aAAa,GAAGH,IAAI,CAACC,KAAL,CAAW,CAACxB,MAAM,GAAG,EAAV,IAAgB,EAA3B,CAApB,CAHgB,CAGwD;;AACxE,UAAI2B,KAAK,GAAG,IAAI/C,aAAJ,CAAkBqC,KAAK,CAACZ,MAAN,CAAaoB,aAAa,GAAG,CAA7B,EAAgC,CAAE,IAAIC,aAAN,IAAuB,EAAvD,CAAlB,EAA8E,CAA9E,CAAZ;AACA,aAAOjB,IAAI,CAACxB,gBAAL,CAAsB0C,KAAtB,EAA6BtC,IAA7B,CAAP;AACH,KANM,EAAP;AAOH;;AAED,MAAIW,MAAM,GAAG,KAAKV,gBAAL,CAAsBD,IAAtB,CAAb;AACA,MAAIsC,KAAK,GAAG,IAAI/C,aAAJ,CAAkBqC,KAAK,CAACZ,MAAN,CAAaa,MAAM,GAAG,CAAtB,EAAyBlB,MAAM,GAAG,CAAlC,CAAlB,CAAZ;AACA,SAAO,KAAKf,gBAAL,CAAsB0C,KAAtB,EAA6BtC,IAA7B,CAAP;AACH,CArDD;;AAuDAuC,MAAM,CAACC,OAAP,GAAiBhD,YAAjB","sourcesContent":["var f = require('./formatters');\nvar SolidityParam = require('./param');\n\n/**\n * SolidityType prototype is used to encode/decode solidity params of certain type\n */\nvar SolidityType = function (config) {\n    this._inputFormatter = config.inputFormatter;\n    this._outputFormatter = config.outputFormatter;\n};\n\n/**\n * Should be used to determine if this SolidityType do match given name\n *\n * @method isType\n * @param {String} name\n * @return {Bool} true if type match this SolidityType, otherwise false\n */\nSolidityType.prototype.isType = function (name) {\n    throw \"this method should be overrwritten for type \" + name;\n};\n\n/**\n * Should be used to determine what is the length of static part in given type\n *\n * @method staticPartLength\n * @param {String} name\n * @return {Number} length of static part in bytes\n */\nSolidityType.prototype.staticPartLength = function (name) {\n    // If name isn't an array then treat it like a single element array.\n    return (this.nestedTypes(name) || ['[1]'])\n        .map(function (type) {\n            // the length of the nested array\n            return parseInt(type.slice(1, -1), 10) || 1;\n        })\n        .reduce(function (previous, current) {\n            return previous * current;\n        // all basic types are 32 bytes long\n        }, 32);\n};\n\n/**\n * Should be used to determine if type is dynamic array\n * eg:\n * \"type[]\" => true\n * \"type[4]\" => false\n *\n * @method isDynamicArray\n * @param {String} name\n * @return {Bool} true if the type is dynamic array\n */\nSolidityType.prototype.isDynamicArray = function (name) {\n    var nestedTypes = this.nestedTypes(name);\n    return !!nestedTypes && !nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);\n};\n\n/**\n * Should be used to determine if type is static array\n * eg:\n * \"type[]\" => false\n * \"type[4]\" => true\n *\n * @method isStaticArray\n * @param {String} name\n * @return {Bool} true if the type is static array\n */\nSolidityType.prototype.isStaticArray = function (name) {\n    var nestedTypes = this.nestedTypes(name);\n    return !!nestedTypes && !!nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);\n};\n\n/**\n * Should return length of static array\n * eg.\n * \"int[32]\" => 32\n * \"int256[14]\" => 14\n * \"int[2][3]\" => 3\n * \"int\" => 1\n * \"int[1]\" => 1\n * \"int[]\" => 1\n *\n * @method staticArrayLength\n * @param {String} name\n * @return {Number} static array length\n */\nSolidityType.prototype.staticArrayLength = function (name) {\n    var nestedTypes = this.nestedTypes(name);\n    if (nestedTypes) {\n       return parseInt(nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g) || 1);\n    }\n    return 1;\n};\n\n/**\n * Should return nested type\n * eg.\n * \"int[32]\" => \"int\"\n * \"int256[14]\" => \"int256\"\n * \"int[2][3]\" => \"int[2]\"\n * \"int\" => \"int\"\n * \"int[]\" => \"int\"\n *\n * @method nestedName\n * @param {String} name\n * @return {String} nested name\n */\nSolidityType.prototype.nestedName = function (name) {\n    // remove last [] in name\n    var nestedTypes = this.nestedTypes(name);\n    if (!nestedTypes) {\n        return name;\n    }\n\n    return name.substr(0, name.length - nestedTypes[nestedTypes.length - 1].length);\n};\n\n/**\n * Should return true if type has dynamic size by default\n * such types are \"string\", \"bytes\"\n *\n * @method isDynamicType\n * @param {String} name\n * @return {Bool} true if is dynamic, otherwise false\n */\nSolidityType.prototype.isDynamicType = function () {\n    return false;\n};\n\n/**\n * Should return array of nested types\n * eg.\n * \"int[2][3][]\" => [\"[2]\", \"[3]\", \"[]\"]\n * \"int[] => [\"[]\"]\n * \"int\" => null\n *\n * @method nestedTypes\n * @param {String} name\n * @return {Array} array of nested types\n */\nSolidityType.prototype.nestedTypes = function (name) {\n    // return list of strings eg. \"[]\", \"[3]\", \"[]\", \"[2]\"\n    return name.match(/(\\[[0-9]*\\])/g);\n};\n\n/**\n * Should be used to encode the value\n *\n * @method encode\n * @param {Object} value\n * @param {String} name\n * @return {String} encoded value\n */\nSolidityType.prototype.encode = function (value, name) {\n    var self = this;\n    if (this.isDynamicArray(name)) {\n\n        return (function () {\n            var length = value.length;                          // in int\n            var nestedName = self.nestedName(name);\n\n            var result = [];\n            result.push(f.formatInputInt(length).encode());\n\n            value.forEach(function (v) {\n                result.push(self.encode(v, nestedName));\n            });\n\n            return result;\n        })();\n\n    } else if (this.isStaticArray(name)) {\n\n        return (function () {\n            var length = self.staticArrayLength(name);          // in int\n            var nestedName = self.nestedName(name);\n\n            var result = [];\n            for (var i = 0; i < length; i++) {\n                result.push(self.encode(value[i], nestedName));\n            }\n\n            return result;\n        })();\n\n    }\n\n    return this._inputFormatter(value, name).encode();\n};\n\n/**\n * Should be used to decode value from bytes\n *\n * @method decode\n * @param {String} bytes\n * @param {Number} offset in bytes\n * @param {String} name type name\n * @returns {Object} decoded value\n */\nSolidityType.prototype.decode = function (bytes, offset, name) {\n    var self = this;\n\n    if (this.isDynamicArray(name)) {\n\n        return (function () {\n            var arrayOffset = parseInt('0x' + bytes.substr(offset * 2, 64)); // in bytes\n            var length = parseInt('0x' + bytes.substr(arrayOffset * 2, 64)); // in int\n            var arrayStart = arrayOffset + 32; // array starts after length; // in bytes\n\n            var nestedName = self.nestedName(name);\n            var nestedStaticPartLength = self.staticPartLength(nestedName);  // in bytes\n            var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;\n            var result = [];\n\n            for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {\n                result.push(self.decode(bytes, arrayStart + i, nestedName));\n            }\n\n            return result;\n        })();\n\n    } else if (this.isStaticArray(name)) {\n\n        return (function () {\n            var length = self.staticArrayLength(name);                      // in int\n            var arrayStart = offset;                                        // in bytes\n\n            var nestedName = self.nestedName(name);\n            var nestedStaticPartLength = self.staticPartLength(nestedName); // in bytes\n            var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;\n            var result = [];\n\n            for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {\n                result.push(self.decode(bytes, arrayStart + i, nestedName));\n            }\n\n            return result;\n        })();\n    } else if (this.isDynamicType(name)) {\n\n        return (function () {\n            var dynamicOffset = parseInt('0x' + bytes.substr(offset * 2, 64));      // in bytes\n            var length = parseInt('0x' + bytes.substr(dynamicOffset * 2, 64));      // in bytes\n            var roundedLength = Math.floor((length + 31) / 32);                     // in int\n            var param = new SolidityParam(bytes.substr(dynamicOffset * 2, ( 1 + roundedLength) * 64), 0);\n            return self._outputFormatter(param, name);\n        })();\n    }\n\n    var length = this.staticPartLength(name);\n    var param = new SolidityParam(bytes.substr(offset * 2, length * 2));\n    return this._outputFormatter(param, name);\n};\n\nmodule.exports = SolidityType;\n"]},"metadata":{},"sourceType":"script"}